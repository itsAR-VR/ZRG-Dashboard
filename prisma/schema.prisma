// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum ClientMemberRole {
  ADMIN
  SETTER
  INBOX_MANAGER
  CLIENT_PORTAL
}

enum MeetingBookingProvider {
  GHL
  CALENDLY
}

enum AvailabilitySource {
  DEFAULT
  DIRECT_BOOK
}

enum AppointmentStatus {
  CONFIRMED
  CANCELED
  RESCHEDULED
  SHOWED
  NO_SHOW
}

enum AppointmentSource {
  WEBHOOK
  RECONCILE_CRON
  BACKFILL
  AUTO_BOOK
  MANUAL
  MIGRATION
}

enum CampaignResponseMode {
  SETTER_MANAGED
  AI_AUTO_SEND
}

enum AIDraftResponseDisposition {
  AUTO_SENT
  APPROVED
  EDITED
}

enum LeadMemorySource {
  MANUAL
  SYSTEM
  INFERENCE
}

enum MemoryEntryStatus {
  APPROVED
  PENDING
}

enum MessagePerformanceProposalStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
}

enum MessagePerformanceProposalType {
  PROMPT_OVERRIDE
  PROMPT_SNIPPET
  KNOWLEDGE_ASSET
}

enum MessagePerformanceEvalStatus {
  PENDING
  COMPLETE
  FAILED
}

enum ConfidenceCalibrationRunStatus {
  PENDING
  RUNNING
  COMPLETE
  FAILED
}

enum ConfidencePolicyProposalStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
}

enum AutoSendScheduleMode {
  ALWAYS
  BUSINESS_HOURS
  CUSTOM
}

enum CrmResponseMode {
  AI
  HUMAN
  UNKNOWN
}

enum EmailIntegrationProvider {
  EMAILBISON
  SMARTLEAD
  INSTANTLY
}

enum InsightsWindowPreset {
  H24
  D7
  D30
  CUSTOM
}

enum InsightChatRole {
  USER
  ASSISTANT
  SYSTEM
}

enum InsightContextPackStatus {
  PENDING
  RUNNING
  COMPLETE
  FAILED
}

enum ConversationInsightOutcome {
  BOOKED
  REQUESTED
  STALLED
  NO_RESPONSE
  UNKNOWN
}

enum InsightChatAuditAction {
  SESSION_CREATED
  SESSION_DELETED
  SESSION_RESTORED
  MESSAGE_CREATED
  CONTEXT_PACK_CREATED
  CONTEXT_PACK_RECOMPUTED
  CONTEXT_PACK_DELETED
}

enum BackgroundJobType {
  EMAIL_INBOUND_POST_PROCESS
  SMS_INBOUND_POST_PROCESS
  LINKEDIN_INBOUND_POST_PROCESS
  SMARTLEAD_INBOUND_POST_PROCESS
  INSTANTLY_INBOUND_POST_PROCESS
  LEAD_SCORING_POST_PROCESS
  CONVERSATION_SYNC
  AI_AUTO_SEND_DELAYED // Phase 47l: Delayed auto-send execution
}

enum BackgroundJobStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
}

// Webhook event queue (Phase 53): lightweight ingestion queue to absorb bursty providers.
enum WebhookProvider {
  INBOXXIA
}

enum WebhookEventStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
}

enum BookingProcessLinkType {
  PLAIN_URL
  HYPERLINKED_TEXT
}

enum BookingStageInstructionOrder {
  QUESTIONS_FIRST
  TIMES_FIRST
  LINK_FIRST
}

// Stores GHL API Keys per sub-account for multi-tenancy
// Each workspace is tied to a user (from Supabase Auth)
model Client {
  id            String              @id @default(uuid())
  name          String
  ghlLocationId String?             @unique // Used to identify which client sent the webhook
  ghlPrivateKey String?             // The generic API key for this sub-account
  // Email integrations (single-select; EmailBison | SmartLead | Instantly)
  emailProvider         EmailIntegrationProvider?
  emailBisonApiKey     String?
  emailBisonWorkspaceId String?     @unique // EmailBison workspace ID for webhook matching
  emailBisonBaseHostId  String?
  smartLeadApiKey       String?
  smartLeadWebhookSecret String?
  instantlyApiKey       String?
  instantlyWebhookSecret String?
  // Slack integration (workspace-level)
  slackBotToken     String?
  // Resend integration (workspace-level)
  resendApiKey      String?
  resendFromEmail   String?
  userId        String              // Supabase Auth user ID - ties workspace to user
  // LinkedIn/Unipile integration (per-workspace account)
  unipileAccountId        String?      // Unipile account ID for LinkedIn messaging
  // Unipile connection health tracking (for admin notifications)
  unipileConnectionStatus String?      // CONNECTED | DISCONNECTED | UNKNOWN
  unipileDisconnectedAt   DateTime?    // When disconnect was first detected
  unipileLastErrorAt      DateTime?    // Last time a Unipile error occurred
  unipileLastErrorMessage String?  @db.Text // Last error message/detail
  unipileLastNotifiedAt   DateTime?    // Last Slack notification sent (for 1/day dedupe)
  // Calendly integration (per-workspace)
  calendlyAccessToken          String?
  calendlyUserUri              String?
  calendlyOrganizationUri      String?
  calendlyWebhookSubscriptionUri String?
  calendlyWebhookSigningKey    String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  members       ClientMember[]
  leads         Lead[]
  campaigns     Campaign[]
  smsCampaigns  SmsCampaign[]
  emailCampaigns EmailCampaign[]
  reactivationCampaigns ReactivationCampaign[]
  senderEmailSnapshots EmailBisonSenderEmailSnapshot[]
  reactivationSenderDailyUsage ReactivationSenderDailyUsage[]
  settings      WorkspaceSettings?  // One-to-one relation with settings
  followUpSequences FollowUpSequence[]  // Follow-up sequence templates
  calendarLinks CalendarLink[]      // Multiple calendar links for availability
  availabilityCaches WorkspaceAvailabilityCache[]
  offeredSlots   WorkspaceOfferedSlot[]
  aiInteractions AIInteraction[]
  meetingOverseerDecisions MeetingOverseerDecision[]
  backgroundJobs BackgroundJob[]
  draftPipelineRuns DraftPipelineRun[]
  notificationEvents NotificationEvent[]
  notificationSendLogs NotificationSendLog[]
  leadAssignmentEvents LeadAssignmentEvent[]
  insightChatSessions InsightChatSession[]
  insightContextPacks InsightContextPack[]
  insightChatUserPreferences InsightChatUserPreference[]
  insightChatAuditEvents InsightChatAuditEvent[]
  bookingProcesses BookingProcess[]
  aiPersonas AiPersona[]           // AI personas for draft generation (Phase 39)
  promptOverrides PromptOverride[] // AI prompt overrides (Phase 47)
  promptSnippetOverrides PromptSnippetOverride[] // AI prompt snippet overrides (Phase 47)
  promptOverrideRevisions PromptOverrideRevision[]
  promptSnippetOverrideRevisions PromptSnippetOverrideRevision[]
  leadMemoryEntries LeadMemoryEntry[]
  workspaceMemoryEntries WorkspaceMemoryEntry[]
  knowledgeAssetRevisions KnowledgeAssetRevision[]
  messagePerformanceEvalRuns MessagePerformanceEvalRun[]
  messagePerformanceProposals MessagePerformanceProposal[]
  confidenceCalibrationRuns ConfidenceCalibrationRun[]
  confidencePolicies ConfidencePolicy[]
  confidencePolicyProposals ConfidencePolicyProposal[]
  confidencePolicyRevisions ConfidencePolicyRevision[]
  emailBisonBaseHost EmailBisonBaseHost? @relation(fields: [emailBisonBaseHostId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([emailBisonBaseHostId])
}

model ClientMember {
  id        String           @id @default(uuid())
  clientId  String
  userId    String           // Supabase Auth user ID
  role      ClientMemberRole
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, userId, role])
  @@index([userId])
  @@index([clientId])
}

// EmailBison base host allowlist (hostname only). Workspaces can select one base host.
model EmailBisonBaseHost {
  id        String   @id @default(uuid())
  host      String   @unique
  label     String?
  clients   Client[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Workspace-specific settings (AI personality, automation, etc.)
model WorkspaceSettings {
  id                   String   @id @default(uuid())
  clientId             String   @unique // Links to workspace
  client               Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  // White-label branding (workspace-level)
  brandName             String?
  brandLogoUrl          String?
  // AI Personality Settings
  aiPersonaName        String?
  aiTone               String?  @default("friendly-professional")
  aiGreeting           String?  // Default greeting for Email channel
  aiSmsGreeting        String?  // Default greeting for SMS channel (falls back to aiGreeting if null)
  aiSignature          String?  @db.Text
  aiGoals              String?  @db.Text
  chatgptExportDefaults String? @db.Text // JSON string (see lib/chatgpt-export.ts)
  // Campaign Assistant (read-only v1; action tools are gated by toggles)
  insightsChatModel String? @default("gpt-5-mini")
  insightsChatReasoningEffort String? @default("medium") // low | medium | high | extra_high (gpt-5.2 only)
  insightsChatEnableCampaignChanges Boolean @default(false)
  insightsChatEnableExperimentWrites Boolean @default(false)
  insightsChatEnableFollowupPauses Boolean @default(false)
  messagePerformanceWeeklyEnabled Boolean @default(false)
  // Draft Generation Model Settings (email two-step pipeline)
  draftGenerationModel           String? @default("gpt-5.1") // gpt-5.1 | gpt-5.2
  draftGenerationReasoningEffort String? @default("medium")  // low | medium | high | extra_high (gpt-5.2 only)
  // Email Draft Verification Model Settings (Step 3 verifier)
  emailDraftVerificationModel    String? @default("gpt-5.2") // gpt-5-mini | gpt-5.1 | gpt-5.2
  // AI Context Fields (for better AI responses)
  serviceDescription      String?  @db.Text  // Business/service description for AI context
  qualificationQuestions  String?  @db.Text  // JSON array of qualification questions
  idealCustomerProfile    String?  @db.Text  // Ideal Customer Profile for lead scoring (Phase 33)
  // Phase 112: Shared lead context bundle + followup booking gate (super-admin controlled)
  leadContextBundleEnabled Boolean @default(false)
  leadContextBundleBudgets Json?
  followupBookingGateEnabled Boolean @default(false)
  // Company/Outreach Context
  companyName             String?             // Company name for {company} variable in templates
  targetResult            String?  @db.Text   // Outcome/result for {result} variable (e.g., "growing your client base")
  // Automation Rules
  autoApproveMeetings  Boolean  @default(true)
  flagUncertainReplies Boolean  @default(true)
  pauseForOOO          Boolean  @default(true)
  // Workspace-level follow-up pause (end-of-day in workspace timezone).
  // When set to a future timestamp, follow-up automation should not auto-enroll or send outbound follow-ups.
  followUpsPausedUntil DateTime?
  autoBlacklist        Boolean  @default(true)
  autoFollowUpsOnReply Boolean  @default(false) // When true, auto-enable follow-ups for leads after a positive inbound EMAIL reply.
  airtableMode         Boolean  @default(false) // When true, email is handled externally (Airtable/n8n); follow-up sequences should be SMS/LinkedIn only.
  // Round-robin lead assignment (Phase 43)
  roundRobinEnabled         Boolean  @default(false)  // When true, new positive leads are assigned to setters in rotation
  roundRobinLastSetterIndex Int?                      // Index of last assigned setter (for rotation)
  // Weighted round-robin sequence (Phase 89)
  roundRobinSetterSequence  String[] @default([])     // Ordered Supabase Auth user IDs; duplicates allowed for weighting
  roundRobinEmailOnly       Boolean  @default(false)  // When true, only Email inbound triggers assignment
  // Notification Settings
  emailDigest          Boolean  @default(true)
  slackAlerts          Boolean  @default(true)
  notificationEmails         String[] @default([])
  notificationPhones         String[] @default([])
  notificationSlackChannelIds String[] @default([]) // Slack conversation IDs (C*/G*)
  notificationSentimentRules Json? // Sentiment -> { mode, destinations }
  notificationDailyDigestTime String? @default("09:00") // Local time in workspace timezone (HH:mm)
  // Schedule Settings
  timezone             String?
  workStartTime        String?  @default("09:00")
  workEndTime          String?  @default("17:00")
  autoSendScheduleMode   AutoSendScheduleMode @default(ALWAYS)
  autoSendCustomSchedule Json?
  // Phase 116: Per-workspace rollout toggle for the Phase 115 auto-send revision loop.
  // Global kill-switch `AUTO_SEND_REVISION_DISABLED=1` still overrides this.
  autoSendRevisionEnabled Boolean @default(false)
  // Phase 123: Auto-send revision loop model tuning (super-admin controlled).
  autoSendRevisionModel            String? @default("gpt-5.2") // gpt-5-mini | gpt-5.1 | gpt-5.2
  autoSendRevisionReasoningEffort  String? @default("high") // low | medium | high | extra_high (gpt-5.2 only)
  autoSendRevisionMaxIterations    Int?    @default(3)
  // Phase 127: Auto-send evaluator model tuning (super-admin controlled).
  // NOTE: If null/unset, code should fall back to env vars or defaults.
  autoSendEvaluatorModel           String? // gpt-5-mini | gpt-5.1 | gpt-5.2
  autoSendEvaluatorReasoningEffort String? // low | medium | high | extra_high
  // Phase 127: Governed durable memory policy (super-admin controlled).
  memoryAllowlistCategories String[] @default([])
  memoryMinConfidence      Float    @default(0.7)
  memoryMinTtlDays         Int      @default(1)
  memoryTtlCapDays         Int      @default(90)
  // AI Auto-Send Approval Recipients (Phase 81)
  // JSON array: [{ id: string, displayName: string, avatarUrl?: string, email?: string }]
  slackAutoSendApprovalRecipients Json?
  // Cached Slack members for settings UI (1-hour TTL)
  slackMembersCacheJson           Json?
  slackMembersCachedAt            DateTime?
  // Calendar Settings
  calendarSlotsToShow    Int?     @default(3)   // Number of availability slots to show
  calendarLookAheadDays  Int?     @default(28)  // Days to look ahead for availability
  // Calendar Health (weekly slot sufficiency check)
  calendarHealthEnabled  Boolean  @default(true)
  calendarHealthMinSlots Int      @default(10)
  // EmailBison first-touch availability_slot injection controls (Phase 55/61)
  emailBisonFirstTouchAvailabilitySlotEnabled Boolean @default(true)
  emailBisonAvailabilitySlotTemplate          String?  @db.Text
  emailBisonAvailabilitySlotIncludeWeekends   Boolean @default(false)
  emailBisonAvailabilitySlotCount             Int      @default(2)
  emailBisonAvailabilitySlotPreferWithinDays  Int      @default(5)
  // GHL Meeting Booking Settings
  ghlDefaultCalendarId   String?              // Selected GHL calendar for booking appointments
  ghlDirectBookCalendarId String?             // Optional: separate GHL calendar without qualification questions (Phase 62)
  ghlAssignedUserId      String?              // Default team member assigned to appointments
  autoBookMeetings       Boolean  @default(false)  // Workspace-level auto-book toggle
  meetingDurationMinutes Int      @default(30)     // Default meeting duration in minutes
  meetingTitle           String?  @default("Intro to {companyName}")  // Title template for appointments
  meetingBookingProvider MeetingBookingProvider @default(GHL)
  calendlyEventTypeLink  String?              // Public Calendly link for the event type (calendly.com/...)
  calendlyEventTypeUri   String?              // API URI for the event type (https://api.calendly.com/event_types/...)
  calendlyDirectBookEventTypeLink String?      // Calendly event type link without qualification questions (Phase 62)
  calendlyDirectBookEventTypeUri  String?      // API URI for the direct-book event type (Phase 62)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  // Relations
  knowledgeAssets      KnowledgeAsset[]
  knowledgeAssetRevisions KnowledgeAssetRevision[]
}

// GHL Workflows/Campaigns synced from the API
model Campaign {
  id            String   @id @default(uuid())
  ghlWorkflowId String   @unique
  name          String
  status        String   @default("active") // active, inactive, draft
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leads         Lead[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([clientId])
}

// SMS sub-client attribution (scoped per workspace/client)
model SmsCampaign {
  id             String   @id @default(uuid())
  clientId       String
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name           String
  nameNormalized String
  leads          Lead[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([clientId, nameNormalized])
  @@index([clientId])
}

// Lead/Contact record - unified across SMS, Email, and LinkedIn channels
model Lead {
  id           String        @id @default(uuid())
  // External system IDs (all optional for multi-channel support)
  ghlContactId     String?   @unique // GoHighLevel contact ID (for SMS)
  emailBisonLeadId String?   // Inboxxia/EmailBison lead ID (for Email)
  linkedinId       String?   // Unipile LinkedIn member ID (populated after connection)
  linkedinUrl      String?   // LinkedIn profile URL (normalized format)
  linkedinUnreachableAt DateTime? // When Unipile reports the recipient cannot be reached (Phase 53)
  linkedinUnreachableReason String? @db.Text
  // Contact information
  firstName    String?
  lastName     String?
  email        String?
  phone        String?       // Stored normalized (digits only)
  jobTitle     String?       // Lead job title (CRM sheet "Job Title")
  timezone     String?       // Lead's timezone for availability slot formatting
  // Company information (from EmailBison custom variables)
  companyName      String?   // Lead's actual company name
  companyWebsite   String?   // Company website URL
  companyState     String?   // Company state/region
  industry         String?   // Company industry (EmailBison custom variable)
  employeeHeadcount String?  // Company employee headcount (EmailBison custom variable; raw)
  // Status and sentiment
  status       String        @default("new")
  sentimentTag String?       // e.g., 'Meeting Requested', 'Not Interested', etc.
  // Lead scoring (Phase 33): null=unscored, 0=Blacklist/opt-out, 1-4=scored
  fitScore       Int?
  intentScore    Int?
  overallScore   Int?
  scoreReasoning String?  @db.Text
  scoredAt       DateTime?
  // Message rollups (for inbox "fresh attention" vs "previously required attention")
  lastInboundAt  DateTime?   // Most recent inbound message timestamp
  lastOutboundAt DateTime?   // Most recent outbound message timestamp
  lastZrgOutboundAt DateTime? // Most recent outbound message timestamp where Message.source = "zrg" (Phase 53)
  lastMessageAt DateTime?    // Most recent message timestamp (any direction)
  lastMessageDirection String? // 'inbound' | 'outbound' (derived from most recent message)
  snoozedUntil DateTime?     // When snoozed, hide from inbox until this date
  // Enrichment tracking (for Clay/EmailBison/signature extraction)
  enrichmentStatus   String?   // 'pending' | 'enriched' | 'not_found' | 'not_needed' | 'failed'
  enrichmentSource   String?   // 'emailbison' | 'clay' | 'signature' | 'message_content' | null
  enrichedAt         DateTime? // When enrichment was last completed
  enrichmentRetryCount  Int       @default(0)  // Number of Clay enrichment retry attempts
  enrichmentLastRetry   DateTime?              // When the last retry was attempted
  // Automation settings
  autoReplyEnabled Boolean   @default(false)
  autoFollowUpEnabled Boolean @default(false)
  // Round-robin lead assignment (Phase 43)
  assignedToUserId    String?    // Supabase Auth user ID of assigned setter
  assignedAt          DateTime?  // When assignment occurred
  // SMS deliverability flags
  smsDndActive Boolean @default(false) // GHL indicates contact is in SMS DND window
  smsDndUpdatedAt DateTime? // Last time we detected/cleared SMS DND
  // Meeting booking settings
  autoBookMeetingsEnabled Boolean   @default(true)   // Lead-level auto-book toggle
  offeredSlots            String?   @db.Text         // JSON array of offered time slots
  qualificationAnswers        Json?                  // Extracted qualification answers (Phase 62)
  qualificationAnswersExtractedAt DateTime?           // When answers were last extracted (Phase 62)
  bookedSlot              String?                    // ISO datetime of booked slot (for filtering availability)
  ghlAppointmentId        String?                    // GHL appointment ID after booking
  calendlyInviteeUri          String? @unique        // Calendly invitee resource URI after booking
  calendlyScheduledEventUri   String? @unique        // Calendly scheduled event resource URI after booking
  appointmentBookedAt     DateTime?                  // When the appointment was booked
  // Reconciliation-focused appointment tracking (Phase 28)
  appointmentStartAt        DateTime?                // Provider-reported appointment start time
  appointmentEndAt          DateTime?                // Provider-reported appointment end time
  appointmentStatus         String?                  // Normalized: confirmed | canceled | rescheduled | showed | no_show
  appointmentCanceledAt     DateTime?                // When cancellation was detected
  appointmentProvider       MeetingBookingProvider?  // Which provider the appointment came from (GHL | CALENDLY)
  appointmentSource         String?                  // How we learned about it: webhook | reconcile_cron | backfill | auto_book | manual
  appointmentLastCheckedAt  DateTime?                // Reconciliation watermark for cron/backfills
  // Workspace and campaign associations
  clientId     String
  client       Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  campaignId   String?       // Optional link to SMS campaign
  campaign     Campaign?     @relation(fields: [campaignId], references: [id])
  smsCampaignId String?      // Optional link to SMS sub-client
  smsCampaign   SmsCampaign? @relation(fields: [smsCampaignId], references: [id])
  emailCampaignId String?    // Optional link to EmailBison campaign
  emailCampaign   EmailCampaign? @relation(fields: [emailCampaignId], references: [id])
  senderAccountId String?    // EmailBison sender email account id
  // Calendar preferences
  preferredCalendarLinkId String?        // Optional per-lead calendar override
  preferredCalendarLink   CalendarLink?  @relation(fields: [preferredCalendarLinkId], references: [id])
  // Lead-provided scheduler link (Phase 52d)
  externalSchedulingLink String? @db.Text
  externalSchedulingLinkLastSeenAt DateTime?
  // Phase 72: CC'd recipient tracking
  alternateEmails         String[]   @default([])  // Email addresses of people who have replied to this thread
  currentReplierEmail     String?                  // Email of most recent inbound sender (if different from lead.email)
  currentReplierName      String?                  // Name of most recent inbound sender
  currentReplierSince     DateTime?                // When they started being the active replier
  // Relations
  messages          Message[]
  backgroundJobs    BackgroundJob[]
  followUps         FollowUpTask[]
  notificationEvents NotificationEvent[]
  notificationSendLogs NotificationSendLog[]
  assignmentEvents LeadAssignmentEvent[]
  followUpInstances FollowUpInstance[]  // Active follow-up sequences for this lead
  reactivationEnrollments ReactivationEnrollment[]
  aiDrafts          AIDraft[]
  aiInteractions    AIInteraction[]
  meetingOverseerDecisions MeetingOverseerDecision[]
  draftPipelineRuns DraftPipelineRun[]
  leadMemoryEntries LeadMemoryEntry[]
  conversationInsight LeadConversationInsight?
  appointments      Appointment[]   // Appointment history (Phase 34)
  bookingProgress   LeadCampaignBookingProgress[]  // Booking process wave tracking (Phase 36)
  crmRow            LeadCrmRow?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([clientId])
  @@index([campaignId])
  @@index([smsCampaignId])
  @@index([emailCampaignId])
  @@index([emailBisonLeadId])
  @@index([alternateEmails], type: Gin)
  @@index([sentimentTag])
  @@index([email])          // For cross-channel matching
  @@index([phone])          // For cross-channel matching
  @@index([linkedinUrl])    // For LinkedIn matching
  @@index([industry])
  @@index([employeeHeadcount])
  @@index([enrichmentStatus]) // For batch enrichment queries
  @@index([preferredCalendarLinkId])
  @@index([lastInboundAt(sort: Desc)])
  @@index([lastOutboundAt(sort: Desc)])
  @@index([lastZrgOutboundAt(sort: Desc)])
  @@index([lastMessageAt(sort: Desc)])
  @@index([lastMessageDirection])
  @@index([clientId, lastInboundAt(sort: Desc)])
  @@index([clientId, assignedToUserId, lastInboundAt(sort: Desc)])
  
  // Composite indexes for CRM/Inbox cursor pagination and filtering
  @@index([clientId, status])                    // CRM status filter
  @@index([clientId, updatedAt(sort: Desc)])     // CRM/Inbox default sort
  @@index([clientId, status, updatedAt(sort: Desc)]) // Combined filter + sort
  @@index([clientId, sentimentTag, updatedAt(sort: Desc)]) // Sentiment filter + sort
  @@index([clientId, firstName])                 // Name search
  @@index([clientId, lastName])                  // Name search
  // Reconciliation indexes (Phase 28)
  @@index([appointmentLastCheckedAt])            // Cron reconciliation cursor
  @@index([clientId, appointmentLastCheckedAt])  // Workspace-scoped reconciliation
  @@index([appointmentStatus])                   // Filter by appointment state
  // Lead scoring indexes (Phase 33)
  @@index([overallScore])                                      // Filter by score
  @@index([clientId, overallScore])                            // Workspace-scoped score filter
  @@index([clientId, overallScore, updatedAt(sort: Desc)])     // Score filter + sort
  // Round-robin assignment indexes (Phase 43)
  @@index([assignedToUserId])                           // Filter by assignee
  @@index([clientId, assignedToUserId])                 // Workspace + assignee filter (inbox)
}

// =============================================================================
// CRM Analytics Row (Google Sheet replica + pipeline/sales skeleton)
// =============================================================================

model LeadCrmRow {
  id        String   @id @default(uuid())
  leadId    String   @unique
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  // Interest registration snapshot
  interestRegisteredAt DateTime?
  interestType         String?
  interestMessageId    String?
  interestChannel      String?
  interestCampaignName String?

  // Response attribution
  responseMode         CrmResponseMode?
  responseMessageId    String?
  responseSentByUserId String?

  // Lead score snapshot at interest time
  leadScoreAtInterest       Int?
  leadFitScoreAtInterest    Int?
  leadIntentScoreAtInterest Int?

  // CRM editable display fields
  leadType             String?   // Sheet "Lead Type"
  applicationStatus    String?   // Sheet "Application Status"
  leadCategoryOverride String?   // Overrides interestType for CRM display; null = use interestType

  // CRM notes (manual)
  notes String? @db.Text

  // Pipeline tracking (skeleton only; editable later)
  pipelineStage    String?
  pipelineStatus   String?
  pipelineValue    Float?
  pipelineCurrency String?
  pipelineOutcome  String?
  pipelineOutcomeAt DateTime?

  // Sales call tracking (skeleton only; metadata-only)
  salesCallHeldAt          DateTime?
  salesCallOutcome         String?
  salesCallScore           Int?
  salesCallContext         String? @db.Text
  salesCallNotes           String? @db.Text
  salesCallImprovementNotes String? @db.Text
  salesCallRecordingUrl    String? @db.Text
  salesCallOwnerUserId     String?
  salesCallReviewedByUserId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([leadId])
  @@index([interestRegisteredAt(sort: Desc)])
  @@index([interestType])
  @@index([leadCategoryOverride])
  @@index([responseMode])
  @@index([pipelineStage])
  @@index([pipelineOutcome])
}

// =============================================================================
// Appointment History (Phase 34)
// =============================================================================

// Per-lead appointment history tracking (supports multiple appointments, reschedules, cancellations)
model Appointment {
  id                    String    @id @default(uuid())
  leadId                String
  lead                  Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)

  // Provider identification (unique constraints for idempotency)
  provider                  MeetingBookingProvider
  ghlAppointmentId          String?   @unique  // GHL appointment ID (idempotency key)
  calendlyInviteeUri        String?   @unique  // Calendly invitee URI (idempotency key)
  calendlyScheduledEventUri String?            // Calendly event URI (may be shared across invitees)
  // Calendar attribution (Phase 126) - used for capacity/utilization analytics
  ghlCalendarId          String?   // GHL calendarId (matches availability cache meta / settings calendar IDs)
  calendlyEventTypeUri   String?   // Calendly event_type URI (e.g. https://api.calendly.com/event_types/<uuid>)

  // Timing (nullable to support migrating Phase 28 partial rollups safely)
  startAt               DateTime?
  endAt                 DateTime?
  timezone              String?   // Original timezone if available

  // Status tracking
  status                AppointmentStatus
  statusChangedAt       DateTime  @default(now())

  // Cancellation/reschedule tracking
  canceledAt            DateTime?
  cancelReason          String?
  rescheduledFromId     String?   // Best-effort link to previous appointment

  // Source tracking
  source                AppointmentSource

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Self-referential relations for reschedule chain
  rescheduledFrom       Appointment? @relation("AppointmentReschedule", fields: [rescheduledFromId], references: [id])
  rescheduledTo         Appointment[] @relation("AppointmentReschedule")

  @@index([leadId])
  @@index([leadId, status])
  @@index([leadId, status, startAt], name: "idx_appointment_capacity_query")
  @@index([startAt])
  @@index([status])
  @@index([provider])
  @@index([ghlCalendarId])
  @@index([calendlyEventTypeUri])
  @@index([createdAt(sort: Desc)])
}

// =============================================================================
// Insights Console (Workspace-scoped chatbot + context packs)
// =============================================================================

model InsightChatSession {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  title           String
  seedQuestion    String?  @db.Text
  createdByUserId String
  createdByEmail  String?
  deletedAt       DateTime?
  deletedByUserId String?
  deleteReason    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  messages     InsightChatMessage[]
  contextPacks InsightContextPack[]
  auditEvents  InsightChatAuditEvent[]

  @@index([clientId])
  @@index([deletedAt])
  @@index([updatedAt(sort: Desc)])
}

model InsightChatMessage {
  id            String   @id @default(uuid())
  clientId      String
  sessionId     String
  session       InsightChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  role          InsightChatRole
  content       String   @db.Text
  citations     Json?
  authorUserId  String?
  authorEmail   String?
  contextPackId String?
  contextPack   InsightContextPack? @relation(fields: [contextPackId], references: [id], onDelete: SetNull)
  createdAt     DateTime @default(now())

  @@index([clientId])
  @@index([contextPackId])
  @@index([createdAt(sort: Desc)])
  @@index([sessionId])
}

model InsightContextPack {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  sessionId     String
  session       InsightChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  scopeKey      String
  status        InsightContextPackStatus @default(PENDING)

  allCampaigns  Boolean  @default(false)
  windowPreset  InsightsWindowPreset @default(D7)
  windowFrom    DateTime
  windowTo      DateTime

  campaignCap          Int?
  selectedCampaignIds  String[] @default([])
  effectiveCampaignIds String[] @default([])

  targetThreadsTotal Int      @default(0)
  processedThreads   Int      @default(0)
  selectedLeadIds    String[] @default([])
  processedLeadIds   String[] @default([])
  selectedLeadsMeta  Json?

  metricsSnapshot Json?
  synthesis        Json?

  seedAssistantMessageId String?
  model                  String
  reasoningEffort        String
  lastError              String?  @db.Text
  computedAt             DateTime?
  computedByUserId       String?
  computedByEmail        String?

  deletedAt       DateTime?
  deletedByUserId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages    InsightChatMessage[]
  auditEvents InsightChatAuditEvent[]

  @@unique([sessionId, scopeKey])
  @@index([clientId])
  @@index([sessionId])
  @@index([status])
  @@index([computedAt(sort: Desc)])
  @@index([deletedAt])
}

model MessagePerformanceEvalRun {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  windowFrom      DateTime
  windowTo        DateTime
  status          MessagePerformanceEvalStatus @default(PENDING)
  model           String
  reasoningEffort String?
  metricsSnapshot Json?
  output          Json?
  error           String?  @db.Text
  proposalsCreated Int     @default(0)
  computedAt      DateTime?
  computedByUserId String?
  computedByEmail  String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clientId])
  @@index([status])
  @@index([computedAt(sort: Desc)])
}

model MessagePerformanceProposal {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  type            MessagePerformanceProposalType
  status          MessagePerformanceProposalStatus @default(PENDING)
  title           String
  summary         String?
  payload         Json
  evidence        Json?
  sourceRunId     String?
  createdByUserId String?
  createdByEmail  String?
  approvedByUserId String?
  approvedByEmail  String?
  approvedAt       DateTime?
  appliedByUserId  String?
  appliedByEmail   String?
  appliedAt        DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  promptOverrideRevisions PromptOverrideRevision[]
  promptSnippetOverrideRevisions PromptSnippetOverrideRevision[]
  knowledgeAssetRevisions KnowledgeAssetRevision[]

  @@index([clientId])
  @@index([status])
  @@index([type])
  @@index([createdAt(sort: Desc)])
}

// Confidence calibration runs (Phase 112)
model ConfidenceCalibrationRun {
  id               String                        @id @default(uuid())
  clientId         String
  client           Client                        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  windowFrom       DateTime
  windowTo         DateTime
  status           ConfidenceCalibrationRunStatus @default(PENDING)
  model            String
  reasoningEffort  String?
  metricsSnapshot  Json?
  output           Json?
  error            String?                       @db.Text
  proposalsCreated Int                           @default(0)
  computedAt       DateTime?
  computedByUserId String?
  computedByEmail  String?
  createdAt        DateTime                      @default(now())
  updatedAt        DateTime                      @updatedAt

  proposals ConfidencePolicyProposal[]

  @@index([clientId])
  @@index([status])
  @@index([computedAt(sort: Desc)])
}

// Active per-feature confidence policy (Phase 112)
model ConfidencePolicy {
  id        String   @id @default(uuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  policyKey String
  config    Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  revisions ConfidencePolicyRevision[]

  @@unique([clientId, policyKey])
  @@index([clientId])
  @@index([policyKey])
}

// Proposed confidence policy changes (Phase 112)
model ConfidencePolicyProposal {
  id               String                      @id @default(uuid())
  clientId         String
  client           Client                      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  policyKey        String
  status           ConfidencePolicyProposalStatus @default(PENDING)
  title            String
  summary          String?
  payload          Json
  evidence         Json?
  sourceRunId      String?
  sourceRun        ConfidenceCalibrationRun?   @relation(fields: [sourceRunId], references: [id], onDelete: SetNull)
  createdByUserId  String?
  createdByEmail   String?
  approvedByUserId String?
  approvedByEmail  String?
  approvedAt       DateTime?
  appliedByUserId  String?
  appliedByEmail   String?
  appliedAt        DateTime?
  createdAt        DateTime                    @default(now())
  updatedAt        DateTime                    @updatedAt

  policyRevisions ConfidencePolicyRevision[]

  @@index([clientId])
  @@index([policyKey])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

// Immutable audit trail for confidence policy changes (Phase 112)
model ConfidencePolicyRevision {
  id                 String   @id @default(uuid())
  clientId           String
  client             Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  confidencePolicyId String?
  confidencePolicy   ConfidencePolicy? @relation(fields: [confidencePolicyId], references: [id], onDelete: SetNull)
  proposalId         String?
  proposal           ConfidencePolicyProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  policyKey          String
  config             Json?
  action             String
  createdByUserId    String?
  createdByEmail     String?
  createdAt          DateTime @default(now())

  @@index([clientId])
  @@index([policyKey])
  @@index([confidencePolicyId])
}

model LeadConversationInsight {
  id               String                     @id @default(uuid())
  leadId           String                     @unique
  lead             Lead                       @relation(fields: [leadId], references: [id], onDelete: Cascade)
  outcome          ConversationInsightOutcome @default(UNKNOWN)
  insight          Json
  model            String
  reasoningEffort  String
  source           String                     @default("chat_pack")
  computedAt       DateTime                   @default(now())
  computedByUserId String?
  computedByEmail  String?
  updatedAt        DateTime                   @updatedAt

  @@index([computedAt(sort: Desc)])
}

model InsightChatUserPreference {
  id           String   @id @default(uuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId       String
  windowPreset InsightsWindowPreset @default(D7)
  windowFrom   DateTime?
  windowTo     DateTime?
  campaignCap  Int @default(10)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([clientId, userId])
  @@index([clientId])
  @@index([userId])
}

model InsightChatAuditEvent {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId        String
  userEmail     String?
  sessionId     String?
  session       InsightChatSession? @relation(fields: [sessionId], references: [id])
  contextPackId String?
  contextPack   InsightContextPack? @relation(fields: [contextPackId], references: [id])
  action        InsightChatAuditAction
  details       Json?
  createdAt     DateTime @default(now())

  @@index([clientId])
  @@index([contextPackId])
  @@index([createdAt(sort: Desc)])
  @@index([sessionId])
}

// Conversation messages across all channels (SMS, Email, LinkedIn)
model Message {
  id        String   @id @default(uuid())
  // External system IDs for deduplication
  ghlId     String?  @unique // GoHighLevel Message ID (SMS)
  emailBisonReplyId String?  @unique // EmailBison reply ID (Email)
  inboxxiaScheduledEmailId String? @unique // Inboxxia scheduled email ID for EMAIL_SENT dedup
  unipileMessageId String?  @unique // Unipile message ID (LinkedIn)
  webhookDedupeKey String?  @unique // Webhook-computed dedupe key (GHL SMS when no ghlId available)
  // Channel and source
  channel   String   @default("sms") // 'sms' | 'email' | 'linkedin'
  source    String   @default("zrg") // 'zrg' | 'inboxxia_campaign' - origin of the message
  // Message content
  body      String   @db.Text
  rawText   String?  @db.Text // Original text body (if provided)
  rawHtml   String?  @db.Text // Original HTML body (if provided)
  subject   String?           // Email subject line
  cc        String[] @default([])
  bcc       String[] @default([])
  // Email participant metadata (Phase 50)
  fromEmail    String?  // Sender email address
  fromName     String?  // Sender display name
  toEmail      String?  // Primary recipient email address
  toName       String?  // Primary recipient display name
  // Status
  isRead    Boolean  @default(false)
  direction String   // 'inbound' or 'outbound'
  // Tracking
  sentBy       String?  // 'ai' | 'setter' (outbound only)
  sentByUserId String?  // Supabase Auth user ID of setter who sent this message (outbound only)
  // AI draft association (Phase 36: now one-to-many for multipart SMS)
  aiDraftId         String?       // When an outbound message was sent from an AI draft
  aiDraftPartIndex  Int?          // Part index for multipart SMS (0, 1, 2); null for single-part
  // Lead association
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  aiDraft   AIDraft? @relation(fields: [aiDraftId], references: [id], onDelete: SetNull)
  backgroundJobs BackgroundJob[]
  meetingOverseerDecisions MeetingOverseerDecision[]
  // Timestamps
  sentAt    DateTime @default(now()) // Actual timestamp when message was sent/received
  createdAt DateTime @default(now()) // When record was created in our database

  @@unique([aiDraftId, aiDraftPartIndex]) // Idempotency for multipart SMS
  @@index([leadId])
  @@index([sentAt(sort: Desc)])
  @@index([source])
  @@index([channel])         // For filtering messages by channel
  @@index([sentByUserId])    // For per-setter response time aggregation
  @@index([aiDraftId])       // For finding all messages from a draft
  @@index([leadId, direction, source, sentAt(sort: Desc)])
}

// Meeting overseer decisions (Phase 106)
model MeetingOverseerDecision {
  id        String   @id @default(uuid())
  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  stage     String   // "extract" | "gate"
  promptKey String
  model     String
  confidence Float?
  payload   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([messageId, stage])
  @@index([clientId])
  @@index([clientId, createdAt(sort: Desc)])
  @@index([leadId])
  @@index([messageId])
}

// Follow-up tasks for leads (individual scheduled tasks)
model FollowUpTask {
  id               String    @id @default(uuid())
  leadId           String
  lead             Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)
  type             String    // 'email', 'call', 'sms', 'linkedin', 'ai_voice'
  dueDate          DateTime
  status           String    @default("pending") // pending, completed, skipped, cancelled
  suggestedMessage String?   @db.Text
  subject          String?   // For email tasks
  // Legacy fields (for backward compatibility)
  sequenceStep     Int?      // Current step in campaign sequence
  totalSteps       Int?      // Total steps in campaign
  campaignName     String?
  // Link to follow-up sequence system (optional)
  instanceId       String?   // Link to FollowUpInstance if part of a sequence
  stepOrder        Int?      // Which step in the sequence this task represents
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([leadId])
  @@index([dueDate])
  @@index([status])
  @@index([instanceId])
}

// Notification events for digesting + auditing (Phase 52d)
model NotificationEvent {
  id        String   @id @default(uuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  kind      String   // 'sentiment'
  sentimentTag String?
  messageId  String?
  dedupeKey String @unique
  createdAt DateTime @default(now())

  @@index([clientId, createdAt(sort: Desc)])
  @@index([leadId, createdAt(sort: Desc)])
  @@index([clientId, kind, createdAt(sort: Desc)])
  @@index([clientId, sentimentTag, createdAt(sort: Desc)])
}

// Notification send log used for idempotent dedupe across destinations (Phase 52d)
model NotificationSendLog {
  id        String   @id @default(uuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId    String?
  lead      Lead?    @relation(fields: [leadId], references: [id], onDelete: SetNull)
  kind      String   // 'sentiment_realtime' | 'daily_digest'
  sentimentTag String?
  destination String // 'slack' | 'email' | 'sms'
  dedupeKey String @unique
  createdAt DateTime @default(now())

  @@index([clientId, createdAt(sort: Desc)])
  @@index([leadId, createdAt(sort: Desc)])
  @@index([clientId, kind, createdAt(sort: Desc)])
}

// Lead assignment audit trail (Phase 89e)
model LeadAssignmentEvent {
  id        String   @id @default(uuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  assignedToUserId String
  assignedByUserId String?
  source    String   // round_robin | backfill | manual
  channel   String?  // sms | email | linkedin
  createdAt DateTime @default(now())

  @@index([clientId, createdAt(sort: Desc)])
  @@index([leadId, createdAt(sort: Desc)])
  @@index([assignedToUserId])
}

// AI-generated draft messages pending approval
model AIDraft {
  id        String   @id @default(uuid())
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  // Phase 123: Optional back-reference to the draft pipeline run that produced this draft.
  draftPipelineRun DraftPipelineRun? @relation("DraftPipelineRunDraft")
  triggerMessageId String? // Inbound Message.id that triggered this draft (idempotency key)
  content   String   @db.Text
  channel   String   @default("sms") // sms | email
  status    String   @default("pending") // pending, approved, rejected
  responseDisposition AIDraftResponseDisposition?
  // Phase 36: one-to-many for multipart SMS (single draft can produce 1-3 outbound messages)
  sentMessages Message[]
  // Phase 47l: Delayed auto-send jobs referencing this draft
  backgroundJobs BackgroundJob[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Phase 70: Persist AI auto-send evaluation metadata (for dashboard visibility + filtering).
  autoSendEvaluatedAt   DateTime?
  autoSendConfidence    Float?
  autoSendThreshold     Float?
  autoSendReason        String?   @db.Text
  autoSendAction        String?   // send_immediate | send_delayed | needs_review | skip | error
  autoSendSlackNotified Boolean   @default(false)

  // Phase 116: Auto-send revision tracking (bounded at-most-once attempt per draft).
  autoSendRevisionAttemptedAt DateTime?
  autoSendOriginalConfidence  Float?
  autoSendRevisionConfidence  Float?
  autoSendRevisionApplied     Boolean @default(false)
  autoSendRevisionSelectorUsed Boolean?
  // Phase 123: Auto-send revision loop iteration tracking.
  autoSendRevisionIterations  Int?     @default(0)

  // Phase 70: Slack notification tracking (for interactive button updates).
  slackNotificationChannelId String?
  slackNotificationMessageTs String?

  @@index([leadId])
  @@index([triggerMessageId])
  @@unique([triggerMessageId, channel])
  @@index([channel])
  @@index([status])
  @@index([responseDisposition], name: "AIDraft_responseDisposition_idx")
  @@index([autoSendAction])
  @@index([autoSendEvaluatedAt])
  @@index([autoSendRevisionAttemptedAt])
}

// Phase 123: Run-scoped draft pipeline persistence (cross-agent context + iteration artifacts).
model DraftPipelineRun {
  id               String   @id @default(uuid())
  clientId         String
  client           Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId           String
  lead             Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  triggerMessageId String?
  draftId          String?  @unique
  draft            AIDraft? @relation("DraftPipelineRunDraft", fields: [draftId], references: [id], onDelete: SetNull)
  channel          String   // email | sms | linkedin
  status           String   @default("RUNNING") // RUNNING | COMPLETED | FAILED | ABORTED
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  artifacts DraftPipelineArtifact[]

  @@unique([triggerMessageId, channel])
  @@index([draftId])
  @@index([clientId, createdAt(sort: Desc)])
  @@index([leadId, createdAt(sort: Desc)])
}

model DraftPipelineArtifact {
  id           String          @id @default(uuid())
  runId        String
  run          DraftPipelineRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  stage        String
  iteration    Int             @default(0) // 0 = baseline, 1-3 = loop iterations
  promptKey    String?
  model        String?
  payload      Json?
  text         String?         @db.Text
  inputTokens  Int?
  outputTokens Int?
  latencyMs    Int?
  createdAt    DateTime        @default(now())

  @@unique([runId, stage, iteration])
  @@index([runId, createdAt])
}

model BackgroundJob {
  id          String            @id @default(uuid())
  type        BackgroundJobType
  status      BackgroundJobStatus @default(PENDING)
  dedupeKey   String            @unique

  clientId    String
  client      Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId      String
  lead        Lead              @relation(fields: [leadId], references: [id], onDelete: Cascade)
  messageId   String
  message     Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)
  // Phase 47l: Optional draft ID for delayed auto-send jobs
  draftId     String?
  draft       AIDraft?          @relation(fields: [draftId], references: [id], onDelete: SetNull)

  runAt       DateTime          @default(now())
  attempts    Int               @default(0)
  maxAttempts Int               @default(5)
  lockedAt    DateTime?
  lockedBy    String?
  startedAt   DateTime?
  finishedAt  DateTime?
  lastError   String?           @db.Text

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([status, runAt])
  @@index([clientId])
  @@index([leadId])
  @@index([messageId])
  @@index([draftId])
}

// Phase 53: durable queue for bursty webhook events (e.g., Inboxxia EMAIL_SENT).
// This avoids doing lead/campaign upserts and follow-up triggers on the request path.
model WebhookEvent {
  id        String @id @default(uuid())
  provider  WebhookProvider
  eventType String
  dedupeKey String @unique

  status      WebhookEventStatus @default(PENDING)
  runAt       DateTime @default(now())
  attempts    Int      @default(0)
  maxAttempts Int      @default(8)
  lockedAt    DateTime?
  lockedBy    String?
  startedAt   DateTime?
  finishedAt  DateTime?
  lastError   String?  @db.Text

  // Normalized payload fields (primarily Inboxxia/EmailBison today).
  workspaceId     String?
  workspaceName   String?
  campaignId      String?
  campaignName    String?
  emailBisonLeadId String?
  leadEmail       String?
  leadFirstName   String?
  leadLastName    String?
  senderEmailId   String?
  senderEmail     String?
  senderName      String?
  scheduledEmailId String?
  emailSubject    String?
  emailBodyHtml   String? @db.Text
  emailStatus     String?
  emailSentAt     DateTime?

  raw Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, runAt])
  @@index([provider, eventType])
  @@index([workspaceId])
  @@index([scheduledEmailId])
}

// AI usage telemetry (admin-only observability)
model AIInteraction {
  id           String   @id @default(uuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId       String?
  lead         Lead?    @relation(fields: [leadId], references: [id], onDelete: SetNull)
  // Attribution key for spend (e.g. "/api/webhooks/email", "/api/cron/followups", "action:insights_chat.send_message")
  source       String?
  featureId    String   // Stable feature key (e.g. "sentiment.classify")
  promptKey    String?  // Optional prompt registry key/version
  model        String
  apiType      String   // "responses" | "chat_completions"
  inputTokens  Int?
  outputTokens Int?
  reasoningTokens Int?
  totalTokens  Int?
  latencyMs    Int?
  status       String   @default("success") // success | error
  errorMessage String?  @db.Text
  metadata     Json?
  createdAt    DateTime @default(now())

  @@index([clientId])
  @@index([leadId])
  @@index([featureId])
  @@index([model])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([clientId, createdAt(sort: Desc)])
  @@index([clientId, featureId, createdAt(sort: Desc)])
  @@index([clientId, source, createdAt(sort: Desc)])
}

// EmailBison campaigns synced per client
model EmailCampaign {
  id             String   @id @default(uuid())
  bisonCampaignId String
  name           String
  clientId       String
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leads          Lead[]
  reactivationCampaigns ReactivationCampaign[]
  responseMode   CampaignResponseMode @default(SETTER_MANAGED)
  autoSendConfidenceThreshold Float @default(0.9)
  // Phase 130: Use only confidence threshold for auto-send (hard blocks still apply)
  autoSendSkipHumanReview Boolean @default(false)
  // Phase 47l: Auto-send delay window (seconds)
  // When responseMode = AI_AUTO_SEND, wait this long after inbound before auto-sending
  autoSendDelayMinSeconds Int @default(180) // 3 minutes
  autoSendDelayMaxSeconds Int @default(420) // 7 minutes
  autoSendScheduleMode     AutoSendScheduleMode?
  autoSendCustomSchedule   Json?
  // Booking process assignment (Phase 36)
  bookingProcessId String?
  bookingProcess   BookingProcess? @relation(fields: [bookingProcessId], references: [id], onDelete: SetNull)
  bookingProgress  LeadCampaignBookingProgress[]  // Booking wave tracking for leads in this campaign
  // AI Persona assignment (Phase 39)
  aiPersonaId      String?
  aiPersona        AiPersona? @relation(fields: [aiPersonaId], references: [id], onDelete: SetNull)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([clientId, bisonCampaignId])
  @@index([clientId])
  @@index([bookingProcessId])
  @@index([aiPersonaId])
}

// Knowledge assets for AI context (uploaded files, text snippets)
model KnowledgeAsset {
  id                  String   @id @default(uuid())
  workspaceSettingsId String
  workspaceSettings   WorkspaceSettings @relation(fields: [workspaceSettingsId], references: [id], onDelete: Cascade)
  name                String              // Display name for the asset
  type                String              // 'file' | 'text' | 'url'
  fileUrl             String?             // Supabase Storage URL (for files)
  textContent         String?  @db.Text   // Extracted or direct text content
  originalFileName    String?             // Original file name if uploaded
  mimeType            String?             // File MIME type
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  revisions           KnowledgeAssetRevision[]

  @@index([workspaceSettingsId])
}

model KnowledgeAssetRevision {
  id                  String   @id @default(uuid())
  clientId            String
  client              Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  workspaceSettingsId String
  workspaceSettings   WorkspaceSettings @relation(fields: [workspaceSettingsId], references: [id], onDelete: Cascade)
  knowledgeAssetId    String
  knowledgeAsset      KnowledgeAsset @relation(fields: [knowledgeAssetId], references: [id], onDelete: Cascade)
  proposalId          String?
  proposal            MessagePerformanceProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  name                String
  type                String
  fileUrl             String?
  textContent         String?  @db.Text
  action              String
  createdByUserId     String?
  createdByEmail      String?
  createdAt           DateTime @default(now())

  @@index([clientId])
  @@index([workspaceSettingsId])
  @@index([knowledgeAssetId])
}

// Lead memory entries (Phase 108)
model LeadMemoryEntry {
  id              String           @id @default(uuid())
  clientId        String
  client          Client           @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId          String
  lead            Lead             @relation(fields: [leadId], references: [id], onDelete: Cascade)
  category        String
  content         String           @db.Text
  source          LeadMemorySource @default(MANUAL)
  status          MemoryEntryStatus @default(APPROVED)
  proposedByDraftPipelineRunId String?
  proposedByDraftId            String?
  createdByUserId String?
  createdByEmail  String?
  expiresAt       DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([clientId])
  @@index([leadId])
  @@index([clientId, leadId])
  @@index([clientId, status])
  @@index([expiresAt])
  @@index([clientId, expiresAt])
  @@index([createdAt(sort: Desc)])
  @@index([proposedByDraftPipelineRunId])
}

model WorkspaceMemoryEntry {
  id              String           @id @default(uuid())
  clientId        String
  client          Client           @relation(fields: [clientId], references: [id], onDelete: Cascade)
  category        String
  content         String           @db.Text
  source          LeadMemorySource @default(MANUAL)
  status          MemoryEntryStatus @default(APPROVED)
  proposedByDraftPipelineRunId String?
  proposedByDraftId            String?
  createdByUserId String?
  createdByEmail  String?
  expiresAt       DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([clientId])
  @@index([clientId, status])
  @@index([expiresAt])
  @@index([clientId, expiresAt])
  @@index([createdAt(sort: Desc)])
  @@index([proposedByDraftPipelineRunId])
}

// =============================================================================
// Follow-Up Sequence System
// =============================================================================

// Client-level follow-up sequence template
model FollowUpSequence {
  id          String   @id @default(uuid())
  name        String
  description String?
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  isActive    Boolean  @default(true)
  triggerOn   String   @default("no_response")  // 'no_response' | 'meeting_selected' | 'manual' | 'setter_reply'
  aiPersonaId String?
  aiPersona   AiPersona? @relation(fields: [aiPersonaId], references: [id], onDelete: SetNull)
  steps       FollowUpStep[]
  instances   FollowUpInstance[]
  reactivationCampaigns ReactivationCampaign[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([clientId])
  @@index([clientId, triggerOn, isActive])
  @@index([aiPersonaId])
  @@index([isActive])
}

// Individual step in a follow-up sequence
model FollowUpStep {
  id               String   @id @default(uuid())
  sequenceId       String
  sequence         FollowUpSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  stepOrder        Int               // Order within the sequence (1, 2, 3...)
  dayOffset        Int               // Day number in the sequence (1 = Day 1, 2 = Day 2, etc.). Backward compatible: 0 treated as Day 1.
  minuteOffset     Int      @default(0) // Minutes after dayOffset boundary (e.g., 2 = +2 min, 60 = +1 hour)
  channel          String            // 'email' | 'sms' | 'linkedin' | 'ai_voice'
  messageTemplate  String?  @db.Text // Template with {variables} like {firstName}, {company}
  subject          String?           // For email subject lines
  condition        String?  @db.Text // JSON condition: { "type": "phone_provided" | "linkedin_connected" | "no_response" }
  requiresApproval Boolean  @default(false)
  fallbackStepId   String?           // If condition fails, skip to this step order

  @@unique([sequenceId, stepOrder])
  @@index([sequenceId])
}

// Per-lead follow-up sequence instance (tracks progress through a sequence)
model FollowUpInstance {
  id             String   @id @default(uuid())
  leadId         String
  lead           Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  sequenceId     String
  sequence       FollowUpSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  currentStep    Int      @default(0)    // Current step order (0 = not started yet)
  status         String   @default("active")  // 'active' | 'paused' | 'completed' | 'cancelled'
  pausedReason   String?                  // Reason for pause (e.g., "lead_replied", "manual")
  startedAt      DateTime @default(now())
  lastStepAt     DateTime?                // When the last step was executed
  nextStepDue    DateTime?                // When the next step should run
  completedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([leadId, sequenceId])
  @@index([leadId])
  @@index([sequenceId])
  @@index([status])
  @@index([nextStepDue])
}

// =============================================================================
// Reactivation (CSV-based lead re-engagement)
// =============================================================================

model ReactivationCampaign {
  id                  String   @id @default(uuid())
  clientId            String
  client              Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name                String
  isActive            Boolean  @default(true)
  // Optional: lock to a single EmailBison campaign (recommended).
  emailCampaignId     String?
  emailCampaign       EmailCampaign? @relation(fields: [emailCampaignId], references: [id], onDelete: SetNull)
  // After bump send, optionally start a follow-up sequence (reuses existing sequencing system).
  followUpSequenceId  String?
  followUpSequence    FollowUpSequence? @relation(fields: [followUpSequenceId], references: [id], onDelete: SetNull)
  // Confirmed requirement: 5/day per sender email address.
  dailyLimitPerSender Int      @default(5)
  // Optional allowlist of sender_email_id values (EmailBison sender emails).
  allowedSenderEmailIds Json?
  // Default bump template. Variables: {firstName}
  bumpMessageTemplate String   @db.Text
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  enrollments         ReactivationEnrollment[]

  @@index([clientId])
  @@index([isActive])
  @@index([emailCampaignId])
  @@index([followUpSequenceId])
}

model ReactivationEnrollment {
  id                 String   @id @default(uuid())
  campaignId         String
  campaign           ReactivationCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  leadId             String
  lead               Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  status             String   @default("pending_resolution") // pending_resolution | ready | sent | rate_limited | needs_review | failed
  needsReviewReason  String?  @db.Text
  // Resolution fields (derived from EmailBison sent thread)
  emailBisonLeadId        String?
  anchorReplyId           String? // Reply ID to respond to for in-thread bump
  anchorCampaignId        String? // EmailBison campaign_id (most recent campaign for the sent thread)
  originalSenderEmailId   String? // sender_email_id used originally
  selectedSenderEmailId   String? // sender_email_id selected (original or fallback)
  deadOriginalSender      Boolean  @default(false)
  deadReason              String?  @db.Text
  // Scheduling + retries
  nextActionAt        DateTime?
  lastAttemptAt       DateTime?
  retryCount          Int      @default(0)
  lastError           String?  @db.Text
  resolvedAt          DateTime?
  sentAt              DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  sendLogs            ReactivationSendLog[]

  @@unique([campaignId, leadId])
  @@index([campaignId])
  @@index([leadId])
  @@index([status])
  @@index([nextActionAt])
  @@index([selectedSenderEmailId])
}

model EmailBisonSenderEmailSnapshot {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  senderEmailId String
  emailAddress  String?
  status        String?
  isSendable    Boolean  @default(true)
  raw           Json?
  fetchedAt     DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, senderEmailId])
  @@index([clientId])
  @@index([clientId, isSendable])
  @@index([fetchedAt])
}

model ReactivationSenderDailyUsage {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  senderEmailId String
  dateKey       String   // YYYY-MM-DD in workspace timezone
  count         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, senderEmailId, dateKey])
  @@index([clientId])
  @@index([senderEmailId])
  @@index([dateKey])
}

model ReactivationSendLog {
  id               String   @id @default(uuid())
  enrollmentId     String
  enrollment       ReactivationEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  stepKey          String   // e.g. "bump_1"
  channel          String   @default("email") // email | sms | linkedin (future)
  senderEmailId    String?
  anchorReplyId    String?
  providerMessageId String?
  status           String   @default("sent") // sent | skipped | error
  error            String?  @db.Text
  sentAt           DateTime @default(now())
  createdAt        DateTime @default(now())

  @@unique([enrollmentId, stepKey])
  @@index([channel])
  @@index([senderEmailId])
  @@index([sentAt(sort: Desc)])
}

// =============================================================================
// Calendar Integration
// =============================================================================

// Calendar links for availability (multiple per workspace)
model CalendarLink {
  id         String   @id @default(uuid())
  clientId   String
  client     Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name       String              // Display name (e.g., "Sales Calendar", "Demo Calls")
  url        String              // Backend: calendar URL used to fetch availability slots from provider APIs
  publicUrl  String?             // Outbound: optional booking link sent to leads (falls back to url when unset)
  type       String              // 'calendly' | 'hubspot' | 'ghl' | 'unknown'
  isDefault  Boolean  @default(false)  // Default calendar for this workspace
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  // Leads that prefer this specific calendar
  leads      Lead[]
  availabilityCaches WorkspaceAvailabilityCache[]

  @@index([clientId])
  @@index([isDefault])
}

// Per-workspace cache of live availability from the default CalendarLink
// Refreshed by cron every 10 minutes (and on-demand when stale).
model WorkspaceAvailabilityCache {
  id                  String      @id @default(uuid())
  clientId            String
  client              Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  availabilitySource  AvailabilitySource @default(DEFAULT)
  calendarLinkId      String?
  calendarLink        CalendarLink? @relation(fields: [calendarLinkId], references: [id], onDelete: SetNull)
  calendarType        String      // 'calendly' | 'hubspot' | 'ghl' | 'unknown'
  calendarUrl         String
  slotDurationMinutes Int         @default(30)
  rangeStart          DateTime
  rangeEnd            DateTime
  slotsUtc            Json        // JSON array of ISO datetimes in UTC
  providerMeta        Json?
  fetchedAt           DateTime
  staleAt             DateTime
  lastError           String?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  @@unique([clientId, availabilitySource])
  @@index([clientId])
  @@index([staleAt])
  @@index([calendarLinkId])
}

// Tracks how often specific availability slots have been offered to leads (soft distribution signal).
// Used to spread suggested times across the next few days before reusing the same slot.
model WorkspaceOfferedSlot {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  availabilitySource AvailabilitySource @default(DEFAULT)
  slotUtc       DateTime
  offeredCount  Int      @default(0)
  lastOfferedAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, availabilitySource, slotUtc])
  @@index([clientId])
  @@index([slotUtc])
  @@index([clientId, availabilitySource, slotUtc])
}

// =============================================================================
// Booking Process System (Phase 36)
// =============================================================================

// Reusable booking process definition per workspace
// Defines when/how the AI offers booking links, times, and qualifying questions
model BookingProcess {
  id          String   @id @default(uuid())
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  name        String
  description String?

  // Global settings
  maxWavesBeforeEscalation Int @default(5)  // Flag for human review after N waves without booking

  stages      BookingProcessStage[]
  campaigns   EmailCampaign[]
  leadProgress LeadCampaignBookingProgress[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Supabase Auth user ID who created

  @@unique([clientId, name])
  @@index([clientId])
}

// Individual stage/wave in a booking process
// Stage numbers are global wave indices shared across channels
model BookingProcessStage {
  id                String   @id @default(uuid())
  bookingProcessId  String
  bookingProcess    BookingProcess @relation(fields: [bookingProcessId], references: [id], onDelete: Cascade)

  stageNumber       Int      // 1, 2, 3... (global wave index)

  // What to include in this stage
  includeBookingLink        Boolean @default(false)
  linkType                  BookingProcessLinkType @default(PLAIN_URL)  // SMS must use PLAIN_URL
  includeSuggestedTimes     Boolean @default(false)
  numberOfTimesToSuggest    Int     @default(3)
  includeQualifyingQuestions Boolean @default(false)
  qualificationQuestionIds  String[] @default([])  // IDs from WorkspaceSettings.qualificationQuestions
  includeTimezoneAsk        Boolean @default(false)
  instructionOrder          BookingStageInstructionOrder?

  // Channel applicability (which channels this stage applies to)
  applyToEmail    Boolean @default(true)
  applyToSms      Boolean @default(true)
  applyToLinkedin Boolean @default(true)

  // Phase 47k: Per-stage instruction text templates (JSON)
  // Keys: bookingLinkPlainTemplate, bookingLinkHyperlinkTemplate, noBookingLinkTemplate,
  //       suggestedTimesWithSlotsTemplate, suggestedTimesNoSlotsTemplate,
  //       qualifyingQuestionOneTemplate, qualifyingQuestionManyTemplate,
  //       smsParaphraseHintTemplate, timezoneAskTemplate, earlyAcceptanceHintTemplate
  instructionTemplates Json?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([bookingProcessId, stageNumber])
  @@index([bookingProcessId])
}

// Per-lead, per-campaign booking wave progress tracking
// Tracks which wave we're on and per-channel sent status within the wave
model LeadCampaignBookingProgress {
  id                String   @id @default(uuid())

  // Scope: per lead + per EmailCampaign
  leadId            String
  lead              Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  emailCampaignId   String
  emailCampaign     EmailCampaign @relation(fields: [emailCampaignId], references: [id], onDelete: Cascade)

  // Freeze booking process at conversation start (do not change mid-stream)
  activeBookingProcessId String?
  activeBookingProcess   BookingProcess? @relation(fields: [activeBookingProcessId], references: [id], onDelete: SetNull)

  // Global wave number (1-indexed). Stage selection uses this.
  currentWave Int @default(1)

  // "This wave already sent a message on channel X"
  waveEmailSent    Boolean @default(false)
  waveSmsSent      Boolean @default(false)
  waveLinkedinSent Boolean @default(false)

  // SMS DND hold tracking (Phase 36i: hold wave until DND clears or 72h timeout)
  smsDndHeldSince   DateTime?  // When DND hold started (null = not held)
  smsDndLastRetryAt DateTime?  // Last DND retry attempt

  // Lifetime outbound counters (used for analytics)
  emailOutboundCount    Int @default(0)
  smsOutboundCount      Int @default(0)
  linkedinOutboundCount Int @default(0)

  lastEmailOutboundAt    DateTime?
  lastSmsOutboundAt      DateTime?
  lastLinkedinOutboundAt DateTime?

  // Required question rotation tracking (Phase 36i: store which required questions were selected)
  selectedRequiredQuestionIds String[] @default([])

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([leadId, emailCampaignId])
  @@index([leadId])
  @@index([emailCampaignId])
  @@index([activeBookingProcessId])
  @@index([currentWave])
  @@index([smsDndHeldSince])  // For cron retry queries
}

// =============================================================================
// AI Prompt Overrides (Phase 47)
// =============================================================================

// Per-workspace prompt override for customizing AI prompt templates
// Allows admins to customize specific messages within prompt templates without code changes
model PromptOverride {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  promptKey       String   // e.g., "sentiment.classify.v1"
  role            String   // "system", "assistant", or "user"
  index           Int      // Message index within the role group (0-based)
  baseContentHash String   // Hash of the default message content at save-time (prevents index drift)
  content         String   @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  revisions PromptOverrideRevision[]

  @@unique([clientId, promptKey, role, index])
  @@index([clientId])
}

// Per-workspace snippet override for customizing reusable text blocks
// Snippets are referenced by templates via placeholders like {forbiddenTerms}
model PromptSnippetOverride {
  id         String   @id @default(uuid())
  clientId   String
  client     Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  snippetKey String   // e.g., "forbiddenTerms", "emailResponseFormattingRules"
  content    String   @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  revisions PromptSnippetOverrideRevision[]

  @@unique([clientId, snippetKey])
  @@index([clientId])
}

model PromptOverrideRevision {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  promptOverrideId String?
  promptOverride  PromptOverride? @relation(fields: [promptOverrideId], references: [id], onDelete: SetNull)
  proposalId      String?
  proposal        MessagePerformanceProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  promptKey       String
  role            String
  index           Int
  baseContentHash String?
  content         String?  @db.Text
  action          String
  createdByUserId String?
  createdByEmail  String?
  createdAt       DateTime @default(now())

  @@index([clientId])
  @@index([promptKey])
  @@index([promptOverrideId])
}

model PromptSnippetOverrideRevision {
  id                     String   @id @default(uuid())
  clientId               String
  client                 Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  promptSnippetOverrideId String?
  promptSnippetOverride  PromptSnippetOverride? @relation(fields: [promptSnippetOverrideId], references: [id], onDelete: SetNull)
  proposalId             String?
  proposal               MessagePerformanceProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  snippetKey             String
  content                String?  @db.Text
  action                 String
  createdByUserId        String?
  createdByEmail         String?
  createdAt              DateTime @default(now())

  @@index([clientId])
  @@index([snippetKey])
  @@index([promptSnippetOverrideId])
}

// =============================================================================
// System Default Prompt Overrides (Phase 129)
// =============================================================================

// System-level prompt override for customizing AI prompt templates globally.
// Applies to all workspaces unless a workspace override exists.
model SystemPromptOverride {
  id              String   @id @default(uuid())
  promptKey       String   // e.g., "sentiment.classify.v1"
  role            String   // "system", "assistant", or "user"
  index           Int      // Message index within the role group (0-based)
  baseContentHash String   // Hash of the code-default message content at save-time (flat drift model)
  content         String   @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  revisions SystemPromptOverrideRevision[]

  @@unique([promptKey, role, index])
  @@index([promptKey])
}

model SystemPromptOverrideRevision {
  id                   String   @id @default(uuid())
  systemPromptOverrideId String?
  systemPromptOverride  SystemPromptOverride? @relation(fields: [systemPromptOverrideId], references: [id], onDelete: SetNull)
  promptKey             String
  role                 String
  index                Int
  baseContentHash       String?
  content               String?  @db.Text
  action                String
  createdByUserId       String?
  createdByEmail        String?
  createdAt             DateTime @default(now())

  @@index([promptKey])
  @@index([systemPromptOverrideId])
}

// System-level snippet override for customizing reusable prompt variables globally.
// Applies to all workspaces unless a workspace override exists.
model SystemPromptSnippetOverride {
  id                String   @id @default(uuid())
  snippetKey         String   // e.g., "forbiddenTerms", "emailLengthRulesTemplate"
  content            String   @db.Text
  codeDefaultSnapshot String? @db.Text // Optional snapshot of code default at save-time (UI warning only)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  revisions SystemPromptSnippetOverrideRevision[]

  @@unique([snippetKey])
  @@index([snippetKey])
}

model SystemPromptSnippetOverrideRevision {
  id                        String   @id @default(uuid())
  systemPromptSnippetOverrideId String?
  systemPromptSnippetOverride  SystemPromptSnippetOverride? @relation(fields: [systemPromptSnippetOverrideId], references: [id], onDelete: SetNull)
  snippetKey                 String
  content                    String?  @db.Text
  action                     String
  createdByUserId            String?
  createdByEmail             String?
  createdAt                  DateTime @default(now())

  @@index([snippetKey])
  @@index([systemPromptSnippetOverrideId])
}

// =============================================================================
// AI Personas (Phase 39)
// =============================================================================

// Reusable AI persona definition per workspace
// Defines how the AI communicates: name, tone, greeting, signature, goals, etc.
model AiPersona {
  id          String   @id @default(uuid())
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  name        String                    // Display name (e.g., "Direct Sales Rep", "Consultative Advisor")
  isDefault   Boolean  @default(false)  // One default per workspace

  // Communication style
  personaName       String?             // AI display name in messages (e.g., "Sarah")
  tone              String   @default("friendly-professional")
  greeting          String?             // Email greeting (e.g., "Hi {firstName},")
  smsGreeting       String?             // SMS greeting (falls back to greeting)
  signature         String?  @db.Text   // Email signature block

  // Strategy & context
  goals             String?  @db.Text   // AI goals & strategy
  serviceDescription String? @db.Text   // Business/service description
  idealCustomerProfile String? @db.Text // ICP for lead scoring context

  // Relations
  campaigns   EmailCampaign[]
  followUpSequences FollowUpSequence[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?                   // Supabase Auth user ID who created

  @@unique([clientId, name])            // Unique persona names per workspace
  @@index([clientId])
  @@index([clientId, isDefault])        // Fast lookup for default persona
}
