// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum ClientMemberRole {
  ADMIN
  SETTER
  INBOX_MANAGER
}

enum MeetingBookingProvider {
  GHL
  CALENDLY
}

enum AppointmentStatus {
  CONFIRMED
  CANCELED
  RESCHEDULED
  SHOWED
  NO_SHOW
}

enum AppointmentSource {
  WEBHOOK
  RECONCILE_CRON
  BACKFILL
  AUTO_BOOK
  MANUAL
  MIGRATION
}

enum CampaignResponseMode {
  SETTER_MANAGED
  AI_AUTO_SEND
}

enum EmailIntegrationProvider {
  EMAILBISON
  SMARTLEAD
  INSTANTLY
}

enum InsightsWindowPreset {
  H24
  D7
  D30
  CUSTOM
}

enum InsightChatRole {
  USER
  ASSISTANT
  SYSTEM
}

enum InsightContextPackStatus {
  PENDING
  RUNNING
  COMPLETE
  FAILED
}

enum ConversationInsightOutcome {
  BOOKED
  REQUESTED
  STALLED
  NO_RESPONSE
  UNKNOWN
}

enum InsightChatAuditAction {
  SESSION_CREATED
  SESSION_DELETED
  SESSION_RESTORED
  MESSAGE_CREATED
  CONTEXT_PACK_CREATED
  CONTEXT_PACK_RECOMPUTED
  CONTEXT_PACK_DELETED
}

enum BackgroundJobType {
  EMAIL_INBOUND_POST_PROCESS
  SMS_INBOUND_POST_PROCESS
  LINKEDIN_INBOUND_POST_PROCESS
  SMARTLEAD_INBOUND_POST_PROCESS
  INSTANTLY_INBOUND_POST_PROCESS
  LEAD_SCORING_POST_PROCESS
}

enum BackgroundJobStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
}

enum BookingProcessLinkType {
  PLAIN_URL
  HYPERLINKED_TEXT
}

// Stores GHL API Keys per sub-account for multi-tenancy
// Each workspace is tied to a user (from Supabase Auth)
model Client {
  id            String              @id @default(uuid())
  name          String
  ghlLocationId String?             @unique // Used to identify which client sent the webhook
  ghlPrivateKey String?             // The generic API key for this sub-account
  // Email integrations (single-select; EmailBison | SmartLead | Instantly)
  emailProvider         EmailIntegrationProvider?
  emailBisonApiKey     String?
  emailBisonWorkspaceId String?     @unique // EmailBison workspace ID for webhook matching
  smartLeadApiKey       String?
  smartLeadWebhookSecret String?
  instantlyApiKey       String?
  instantlyWebhookSecret String?
  userId        String              // Supabase Auth user ID - ties workspace to user
  // LinkedIn/Unipile integration (per-workspace account)
  unipileAccountId        String?      // Unipile account ID for LinkedIn messaging
  // Unipile connection health tracking (for admin notifications)
  unipileConnectionStatus String?      // CONNECTED | DISCONNECTED | UNKNOWN
  unipileDisconnectedAt   DateTime?    // When disconnect was first detected
  unipileLastErrorAt      DateTime?    // Last time a Unipile error occurred
  unipileLastErrorMessage String?  @db.Text // Last error message/detail
  unipileLastNotifiedAt   DateTime?    // Last Slack notification sent (for 1/day dedupe)
  // Calendly integration (per-workspace)
  calendlyAccessToken          String?
  calendlyUserUri              String?
  calendlyOrganizationUri      String?
  calendlyWebhookSubscriptionUri String?
  calendlyWebhookSigningKey    String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  members       ClientMember[]
  leads         Lead[]
  campaigns     Campaign[]
  smsCampaigns  SmsCampaign[]
  emailCampaigns EmailCampaign[]
  reactivationCampaigns ReactivationCampaign[]
  senderEmailSnapshots EmailBisonSenderEmailSnapshot[]
  reactivationSenderDailyUsage ReactivationSenderDailyUsage[]
  settings      WorkspaceSettings?  // One-to-one relation with settings
  followUpSequences FollowUpSequence[]  // Follow-up sequence templates
  calendarLinks CalendarLink[]      // Multiple calendar links for availability
  availabilityCache WorkspaceAvailabilityCache?
  offeredSlots   WorkspaceOfferedSlot[]
  aiInteractions AIInteraction[]
  backgroundJobs BackgroundJob[]
  insightChatSessions InsightChatSession[]
  insightContextPacks InsightContextPack[]
  insightChatUserPreferences InsightChatUserPreference[]
  insightChatAuditEvents InsightChatAuditEvent[]
  bookingProcesses BookingProcess[]

  @@index([userId])
}

model ClientMember {
  id        String           @id @default(uuid())
  clientId  String
  userId    String           // Supabase Auth user ID
  role      ClientMemberRole
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, userId, role])
  @@index([userId])
  @@index([clientId])
}

// Workspace-specific settings (AI personality, automation, etc.)
model WorkspaceSettings {
  id                   String   @id @default(uuid())
  clientId             String   @unique // Links to workspace
  client               Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  // White-label branding (workspace-level)
  brandName             String?
  brandLogoUrl          String?
  // AI Personality Settings
  aiPersonaName        String?
  aiTone               String?  @default("friendly-professional")
  aiGreeting           String?  // Default greeting for Email channel
  aiSmsGreeting        String?  // Default greeting for SMS channel (falls back to aiGreeting if null)
  aiSignature          String?  @db.Text
  aiGoals              String?  @db.Text
  chatgptExportDefaults String? @db.Text // JSON string (see lib/chatgpt-export.ts)
  // Insights Chatbot (read-only v1; action tools are gated by toggles)
  insightsChatModel String? @default("gpt-5-mini")
  insightsChatReasoningEffort String? @default("medium") // low | medium | high | extra_high (gpt-5.2 only)
  insightsChatEnableCampaignChanges Boolean @default(false)
  insightsChatEnableExperimentWrites Boolean @default(false)
  insightsChatEnableFollowupPauses Boolean @default(false)
  // Draft Generation Model Settings (email two-step pipeline)
  draftGenerationModel           String? @default("gpt-5.1") // gpt-5.1 | gpt-5.2
  draftGenerationReasoningEffort String? @default("medium")  // low | medium | high | extra_high (gpt-5.2 only)
  // AI Context Fields (for better AI responses)
  serviceDescription      String?  @db.Text  // Business/service description for AI context
  qualificationQuestions  String?  @db.Text  // JSON array of qualification questions
  idealCustomerProfile    String?  @db.Text  // Ideal Customer Profile for lead scoring (Phase 33)
  // Company/Outreach Context
  companyName             String?             // Company name for {company} variable in templates
  targetResult            String?  @db.Text   // Outcome/result for {result} variable (e.g., "growing your client base")
  // Automation Rules
  autoApproveMeetings  Boolean  @default(true)
  flagUncertainReplies Boolean  @default(true)
  pauseForOOO          Boolean  @default(true)
  // Workspace-level follow-up pause (end-of-day in workspace timezone).
  // When set to a future timestamp, follow-up automation should not auto-enroll or send outbound follow-ups.
  followUpsPausedUntil DateTime?
  autoBlacklist        Boolean  @default(true)
  autoFollowUpsOnReply Boolean  @default(false) // When true, auto-enable follow-ups for leads after a positive inbound EMAIL reply.
  airtableMode         Boolean  @default(false) // When true, email is handled externally (Airtable/n8n); follow-up sequences should be SMS/LinkedIn only.
  // Notification Settings
  emailDigest          Boolean  @default(true)
  slackAlerts          Boolean  @default(true)
  // Schedule Settings
  timezone             String?
  workStartTime        String?  @default("09:00")
  workEndTime          String?  @default("17:00")
  // Calendar Settings
  calendarSlotsToShow    Int?     @default(3)   // Number of availability slots to show
  calendarLookAheadDays  Int?     @default(28)  // Days to look ahead for availability
  // GHL Meeting Booking Settings
  ghlDefaultCalendarId   String?              // Selected GHL calendar for booking appointments
  ghlAssignedUserId      String?              // Default team member assigned to appointments
  autoBookMeetings       Boolean  @default(false)  // Workspace-level auto-book toggle
  meetingDurationMinutes Int      @default(30)     // Default meeting duration in minutes
  meetingTitle           String?  @default("Intro to {companyName}")  // Title template for appointments
  meetingBookingProvider MeetingBookingProvider @default(GHL)
  calendlyEventTypeLink  String?              // Public Calendly link for the event type (calendly.com/...)
  calendlyEventTypeUri   String?              // API URI for the event type (https://api.calendly.com/event_types/...)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  // Relations
  knowledgeAssets      KnowledgeAsset[]
}

// GHL Workflows/Campaigns synced from the API
model Campaign {
  id            String   @id @default(uuid())
  ghlWorkflowId String   @unique
  name          String
  status        String   @default("active") // active, inactive, draft
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leads         Lead[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([clientId])
}

// SMS sub-client attribution (scoped per workspace/client)
model SmsCampaign {
  id             String   @id @default(uuid())
  clientId       String
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name           String
  nameNormalized String
  leads          Lead[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([clientId, nameNormalized])
  @@index([clientId])
}

// Lead/Contact record - unified across SMS, Email, and LinkedIn channels
model Lead {
  id           String        @id @default(uuid())
  // External system IDs (all optional for multi-channel support)
  ghlContactId     String?   @unique // GoHighLevel contact ID (for SMS)
  emailBisonLeadId String?   // Inboxxia/EmailBison lead ID (for Email)
  linkedinId       String?   // Unipile LinkedIn member ID (populated after connection)
  linkedinUrl      String?   // LinkedIn profile URL (normalized format)
  // Contact information
  firstName    String?
  lastName     String?
  email        String?
  phone        String?       // Stored normalized (digits only)
  timezone     String?       // Lead's timezone for availability slot formatting
  // Company information (from EmailBison custom variables)
  companyName      String?   // Lead's actual company name
  companyWebsite   String?   // Company website URL
  companyState     String?   // Company state/region
  industry         String?   // Company industry (EmailBison custom variable)
  employeeHeadcount String?  // Company employee headcount (EmailBison custom variable; raw)
  // Status and sentiment
  status       String        @default("new")
  sentimentTag String?       // e.g., 'Meeting Requested', 'Not Interested', etc.
  // Lead scoring (Phase 33): null=unscored, 0=Blacklist/opt-out, 1-4=scored
  fitScore       Int?
  intentScore    Int?
  overallScore   Int?
  scoreReasoning String?  @db.Text
  scoredAt       DateTime?
  // Message rollups (for inbox "fresh attention" vs "previously required attention")
  lastInboundAt  DateTime?   // Most recent inbound message timestamp
  lastOutboundAt DateTime?   // Most recent outbound message timestamp
  lastMessageAt DateTime?    // Most recent message timestamp (any direction)
  lastMessageDirection String? // 'inbound' | 'outbound' (derived from most recent message)
  snoozedUntil DateTime?     // When snoozed, hide from inbox until this date
  // Enrichment tracking (for Clay/EmailBison/signature extraction)
  enrichmentStatus   String?   // 'pending' | 'enriched' | 'not_found' | 'not_needed' | 'failed'
  enrichmentSource   String?   // 'emailbison' | 'clay' | 'signature' | 'message_content' | null
  enrichedAt         DateTime? // When enrichment was last completed
  enrichmentRetryCount  Int       @default(0)  // Number of Clay enrichment retry attempts
  enrichmentLastRetry   DateTime?              // When the last retry was attempted
  // Automation settings
  autoReplyEnabled Boolean   @default(false)
  autoFollowUpEnabled Boolean @default(false)
  // SMS deliverability flags
  smsDndActive Boolean @default(false) // GHL indicates contact is in SMS DND window
  smsDndUpdatedAt DateTime? // Last time we detected/cleared SMS DND
  // Meeting booking settings
  autoBookMeetingsEnabled Boolean   @default(true)   // Lead-level auto-book toggle
  offeredSlots            String?   @db.Text         // JSON array of offered time slots
  bookedSlot              String?                    // ISO datetime of booked slot (for filtering availability)
  ghlAppointmentId        String?                    // GHL appointment ID after booking
  calendlyInviteeUri          String? @unique        // Calendly invitee resource URI after booking
  calendlyScheduledEventUri   String? @unique        // Calendly scheduled event resource URI after booking
  appointmentBookedAt     DateTime?                  // When the appointment was booked
  // Reconciliation-focused appointment tracking (Phase 28)
  appointmentStartAt        DateTime?                // Provider-reported appointment start time
  appointmentEndAt          DateTime?                // Provider-reported appointment end time
  appointmentStatus         String?                  // Normalized: confirmed | canceled | rescheduled | showed | no_show
  appointmentCanceledAt     DateTime?                // When cancellation was detected
  appointmentProvider       MeetingBookingProvider?  // Which provider the appointment came from (GHL | CALENDLY)
  appointmentSource         String?                  // How we learned about it: webhook | reconcile_cron | backfill | auto_book | manual
  appointmentLastCheckedAt  DateTime?                // Reconciliation watermark for cron/backfills
  // Workspace and campaign associations
  clientId     String
  client       Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  campaignId   String?       // Optional link to SMS campaign
  campaign     Campaign?     @relation(fields: [campaignId], references: [id])
  smsCampaignId String?      // Optional link to SMS sub-client
  smsCampaign   SmsCampaign? @relation(fields: [smsCampaignId], references: [id])
  emailCampaignId String?    // Optional link to EmailBison campaign
  emailCampaign   EmailCampaign? @relation(fields: [emailCampaignId], references: [id])
  senderAccountId String?    // EmailBison sender email account id
  // Calendar preferences
  preferredCalendarLinkId String?        // Optional per-lead calendar override
  preferredCalendarLink   CalendarLink?  @relation(fields: [preferredCalendarLinkId], references: [id])
  // Relations
  messages          Message[]
  backgroundJobs    BackgroundJob[]
  followUps         FollowUpTask[]
  followUpInstances FollowUpInstance[]  // Active follow-up sequences for this lead
  reactivationEnrollments ReactivationEnrollment[]
  aiDrafts          AIDraft[]
  aiInteractions    AIInteraction[]
  conversationInsight LeadConversationInsight?
  appointments      Appointment[]   // Appointment history (Phase 34)
  bookingProgress   LeadCampaignBookingProgress[]  // Booking process wave tracking (Phase 36)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([clientId])
  @@index([campaignId])
  @@index([smsCampaignId])
  @@index([emailCampaignId])
  @@index([emailBisonLeadId])
  @@index([sentimentTag])
  @@index([email])          // For cross-channel matching
  @@index([phone])          // For cross-channel matching
  @@index([linkedinUrl])    // For LinkedIn matching
  @@index([industry])
  @@index([employeeHeadcount])
  @@index([enrichmentStatus]) // For batch enrichment queries
  @@index([preferredCalendarLinkId])
  @@index([lastInboundAt(sort: Desc)])
  @@index([lastOutboundAt(sort: Desc)])
  @@index([lastMessageAt(sort: Desc)])
  @@index([lastMessageDirection])
  
  // Composite indexes for CRM/Inbox cursor pagination and filtering
  @@index([clientId, status])                    // CRM status filter
  @@index([clientId, updatedAt(sort: Desc)])     // CRM/Inbox default sort
  @@index([clientId, status, updatedAt(sort: Desc)]) // Combined filter + sort
  @@index([clientId, sentimentTag, updatedAt(sort: Desc)]) // Sentiment filter + sort
  @@index([clientId, firstName])                 // Name search
  @@index([clientId, lastName])                  // Name search
  // Reconciliation indexes (Phase 28)
  @@index([appointmentLastCheckedAt])            // Cron reconciliation cursor
  @@index([clientId, appointmentLastCheckedAt])  // Workspace-scoped reconciliation
  @@index([appointmentStatus])                   // Filter by appointment state
  // Lead scoring indexes (Phase 33)
  @@index([overallScore])                                      // Filter by score
  @@index([clientId, overallScore])                            // Workspace-scoped score filter
  @@index([clientId, overallScore, updatedAt(sort: Desc)])     // Score filter + sort
}

// =============================================================================
// Appointment History (Phase 34)
// =============================================================================

// Per-lead appointment history tracking (supports multiple appointments, reschedules, cancellations)
model Appointment {
  id                    String    @id @default(uuid())
  leadId                String
  lead                  Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)

  // Provider identification (unique constraints for idempotency)
  provider                  MeetingBookingProvider
  ghlAppointmentId          String?   @unique  // GHL appointment ID (idempotency key)
  calendlyInviteeUri        String?   @unique  // Calendly invitee URI (idempotency key)
  calendlyScheduledEventUri String?            // Calendly event URI (may be shared across invitees)

  // Timing (nullable to support migrating Phase 28 partial rollups safely)
  startAt               DateTime?
  endAt                 DateTime?
  timezone              String?   // Original timezone if available

  // Status tracking
  status                AppointmentStatus
  statusChangedAt       DateTime  @default(now())

  // Cancellation/reschedule tracking
  canceledAt            DateTime?
  cancelReason          String?
  rescheduledFromId     String?   // Best-effort link to previous appointment

  // Source tracking
  source                AppointmentSource

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Self-referential relations for reschedule chain
  rescheduledFrom       Appointment? @relation("AppointmentReschedule", fields: [rescheduledFromId], references: [id])
  rescheduledTo         Appointment[] @relation("AppointmentReschedule")

  @@index([leadId])
  @@index([leadId, status])
  @@index([startAt])
  @@index([status])
  @@index([provider])
  @@index([createdAt(sort: Desc)])
}

// =============================================================================
// Insights Console (Workspace-scoped chatbot + context packs)
// =============================================================================

model InsightChatSession {
  id              String   @id @default(uuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  title           String
  seedQuestion    String?  @db.Text
  createdByUserId String
  createdByEmail  String?
  deletedAt       DateTime?
  deletedByUserId String?
  deleteReason    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  messages     InsightChatMessage[]
  contextPacks InsightContextPack[]
  auditEvents  InsightChatAuditEvent[]

  @@index([clientId])
  @@index([deletedAt])
  @@index([updatedAt(sort: Desc)])
}

model InsightChatMessage {
  id            String   @id @default(uuid())
  clientId      String
  sessionId     String
  session       InsightChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  role          InsightChatRole
  content       String   @db.Text
  citations     Json?
  authorUserId  String?
  authorEmail   String?
  contextPackId String?
  contextPack   InsightContextPack? @relation(fields: [contextPackId], references: [id], onDelete: SetNull)
  createdAt     DateTime @default(now())

  @@index([clientId])
  @@index([contextPackId])
  @@index([createdAt(sort: Desc)])
  @@index([sessionId])
}

model InsightContextPack {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  sessionId     String
  session       InsightChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  scopeKey      String
  status        InsightContextPackStatus @default(PENDING)

  allCampaigns  Boolean  @default(false)
  windowPreset  InsightsWindowPreset @default(D7)
  windowFrom    DateTime
  windowTo      DateTime

  campaignCap          Int?
  selectedCampaignIds  String[] @default([])
  effectiveCampaignIds String[] @default([])

  targetThreadsTotal Int      @default(0)
  processedThreads   Int      @default(0)
  selectedLeadIds    String[] @default([])
  processedLeadIds   String[] @default([])
  selectedLeadsMeta  Json?

  metricsSnapshot Json?
  synthesis        Json?

  seedAssistantMessageId String?
  model                  String
  reasoningEffort        String
  lastError              String?  @db.Text
  computedAt             DateTime?
  computedByUserId       String?
  computedByEmail        String?

  deletedAt       DateTime?
  deletedByUserId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages    InsightChatMessage[]
  auditEvents InsightChatAuditEvent[]

  @@unique([sessionId, scopeKey])
  @@index([clientId])
  @@index([sessionId])
  @@index([status])
  @@index([computedAt(sort: Desc)])
  @@index([deletedAt])
}

model LeadConversationInsight {
  id               String                     @id @default(uuid())
  leadId           String                     @unique
  lead             Lead                       @relation(fields: [leadId], references: [id], onDelete: Cascade)
  outcome          ConversationInsightOutcome @default(UNKNOWN)
  insight          Json
  model            String
  reasoningEffort  String
  source           String                     @default("chat_pack")
  computedAt       DateTime                   @default(now())
  computedByUserId String?
  computedByEmail  String?
  updatedAt        DateTime                   @updatedAt

  @@index([computedAt(sort: Desc)])
}

model InsightChatUserPreference {
  id           String   @id @default(uuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId       String
  windowPreset InsightsWindowPreset @default(D7)
  windowFrom   DateTime?
  windowTo     DateTime?
  campaignCap  Int @default(10)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([clientId, userId])
  @@index([clientId])
  @@index([userId])
}

model InsightChatAuditEvent {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId        String
  userEmail     String?
  sessionId     String?
  session       InsightChatSession? @relation(fields: [sessionId], references: [id])
  contextPackId String?
  contextPack   InsightContextPack? @relation(fields: [contextPackId], references: [id])
  action        InsightChatAuditAction
  details       Json?
  createdAt     DateTime @default(now())

  @@index([clientId])
  @@index([contextPackId])
  @@index([createdAt(sort: Desc)])
  @@index([sessionId])
}

// Conversation messages across all channels (SMS, Email, LinkedIn)
model Message {
  id        String   @id @default(uuid())
  // External system IDs for deduplication
  ghlId     String?  @unique // GoHighLevel Message ID (SMS)
  emailBisonReplyId String?  @unique // EmailBison reply ID (Email)
  inboxxiaScheduledEmailId String? @unique // Inboxxia scheduled email ID for EMAIL_SENT dedup
  unipileMessageId String?  @unique // Unipile message ID (LinkedIn)
  webhookDedupeKey String?  @unique // Webhook-computed dedupe key (GHL SMS when no ghlId available)
  // Channel and source
  channel   String   @default("sms") // 'sms' | 'email' | 'linkedin'
  source    String   @default("zrg") // 'zrg' | 'inboxxia_campaign' - origin of the message
  // Message content
  body      String   @db.Text
  rawText   String?  @db.Text // Original text body (if provided)
  rawHtml   String?  @db.Text // Original HTML body (if provided)
  subject   String?           // Email subject line
  cc        String[] @default([])
  bcc       String[] @default([])
  // Status
  isRead    Boolean  @default(false)
  direction String   // 'inbound' or 'outbound'
  // Tracking
  sentBy       String?  // 'ai' | 'setter' (outbound only)
  sentByUserId String?  // Supabase Auth user ID of setter who sent this message (outbound only)
  // AI draft association (Phase 36: now one-to-many for multipart SMS)
  aiDraftId         String?       // When an outbound message was sent from an AI draft
  aiDraftPartIndex  Int?          // Part index for multipart SMS (0, 1, 2); null for single-part
  // Lead association
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  aiDraft   AIDraft? @relation(fields: [aiDraftId], references: [id], onDelete: SetNull)
  backgroundJobs BackgroundJob[]
  // Timestamps
  sentAt    DateTime @default(now()) // Actual timestamp when message was sent/received
  createdAt DateTime @default(now()) // When record was created in our database

  @@unique([aiDraftId, aiDraftPartIndex]) // Idempotency for multipart SMS
  @@index([leadId])
  @@index([sentAt(sort: Desc)])
  @@index([source])
  @@index([channel])         // For filtering messages by channel
  @@index([sentByUserId])    // For per-setter response time aggregation
  @@index([aiDraftId])       // For finding all messages from a draft
}

// Follow-up tasks for leads (individual scheduled tasks)
model FollowUpTask {
  id               String    @id @default(uuid())
  leadId           String
  lead             Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)
  type             String    // 'email', 'call', 'sms', 'linkedin', 'ai_voice'
  dueDate          DateTime
  status           String    @default("pending") // pending, completed, skipped, cancelled
  suggestedMessage String?   @db.Text
  subject          String?   // For email tasks
  // Legacy fields (for backward compatibility)
  sequenceStep     Int?      // Current step in campaign sequence
  totalSteps       Int?      // Total steps in campaign
  campaignName     String?
  // Link to follow-up sequence system (optional)
  instanceId       String?   // Link to FollowUpInstance if part of a sequence
  stepOrder        Int?      // Which step in the sequence this task represents
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([leadId])
  @@index([dueDate])
  @@index([status])
  @@index([instanceId])
}

// AI-generated draft messages pending approval
model AIDraft {
  id        String   @id @default(uuid())
  leadId    String
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  triggerMessageId String? // Inbound Message.id that triggered this draft (idempotency key)
  content   String   @db.Text
  channel   String   @default("sms") // sms | email
  status    String   @default("pending") // pending, approved, rejected
  // Phase 36: one-to-many for multipart SMS (single draft can produce 1-3 outbound messages)
  sentMessages Message[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([leadId])
  @@index([triggerMessageId])
  @@unique([triggerMessageId, channel])
  @@index([channel])
  @@index([status])
}

model BackgroundJob {
  id          String            @id @default(uuid())
  type        BackgroundJobType
  status      BackgroundJobStatus @default(PENDING)
  dedupeKey   String            @unique

  clientId    String
  client      Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId      String
  lead        Lead              @relation(fields: [leadId], references: [id], onDelete: Cascade)
  messageId   String
  message     Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)

  runAt       DateTime          @default(now())
  attempts    Int               @default(0)
  maxAttempts Int               @default(5)
  lockedAt    DateTime?
  lockedBy    String?
  startedAt   DateTime?
  finishedAt  DateTime?
  lastError   String?           @db.Text

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([status, runAt])
  @@index([clientId])
  @@index([leadId])
  @@index([messageId])
}

// AI usage telemetry (admin-only observability)
model AIInteraction {
  id           String   @id @default(uuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leadId       String?
  lead         Lead?    @relation(fields: [leadId], references: [id], onDelete: SetNull)
  // Attribution key for spend (e.g. "/api/webhooks/email", "/api/cron/followups", "action:insights_chat.send_message")
  source       String?
  featureId    String   // Stable feature key (e.g. "sentiment.classify")
  promptKey    String?  // Optional prompt registry key/version
  model        String
  apiType      String   // "responses" | "chat_completions"
  inputTokens  Int?
  outputTokens Int?
  reasoningTokens Int?
  totalTokens  Int?
  latencyMs    Int?
  status       String   @default("success") // success | error
  errorMessage String?  @db.Text
  createdAt    DateTime @default(now())

  @@index([clientId])
  @@index([leadId])
  @@index([featureId])
  @@index([model])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([clientId, createdAt(sort: Desc)])
  @@index([clientId, featureId, createdAt(sort: Desc)])
  @@index([clientId, source, createdAt(sort: Desc)])
}

// EmailBison campaigns synced per client
model EmailCampaign {
  id             String   @id @default(uuid())
  bisonCampaignId String
  name           String
  clientId       String
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  leads          Lead[]
  reactivationCampaigns ReactivationCampaign[]
  responseMode   CampaignResponseMode @default(SETTER_MANAGED)
  autoSendConfidenceThreshold Float @default(0.9)
  // Booking process assignment (Phase 36)
  bookingProcessId String?
  bookingProcess   BookingProcess? @relation(fields: [bookingProcessId], references: [id], onDelete: SetNull)
  bookingProgress  LeadCampaignBookingProgress[]  // Booking wave tracking for leads in this campaign
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([clientId, bisonCampaignId])
  @@index([clientId])
  @@index([bookingProcessId])
}

// Knowledge assets for AI context (uploaded files, text snippets)
model KnowledgeAsset {
  id                  String   @id @default(uuid())
  workspaceSettingsId String
  workspaceSettings   WorkspaceSettings @relation(fields: [workspaceSettingsId], references: [id], onDelete: Cascade)
  name                String              // Display name for the asset
  type                String              // 'file' | 'text' | 'url'
  fileUrl             String?             // Supabase Storage URL (for files)
  textContent         String?  @db.Text   // Extracted or direct text content
  originalFileName    String?             // Original file name if uploaded
  mimeType            String?             // File MIME type
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([workspaceSettingsId])
}

// =============================================================================
// Follow-Up Sequence System
// =============================================================================

// Client-level follow-up sequence template
model FollowUpSequence {
  id          String   @id @default(uuid())
  name        String
  description String?
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  isActive    Boolean  @default(true)
  triggerOn   String   @default("no_response")  // 'no_response' | 'meeting_selected' | 'manual'
  steps       FollowUpStep[]
  instances   FollowUpInstance[]
  reactivationCampaigns ReactivationCampaign[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([clientId])
  @@index([isActive])
}

// Individual step in a follow-up sequence
model FollowUpStep {
  id               String   @id @default(uuid())
  sequenceId       String
  sequence         FollowUpSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  stepOrder        Int               // Order within the sequence (1, 2, 3...)
  dayOffset        Int               // Days after sequence start (0 = same day, 2 = Day 2, etc.)
  channel          String            // 'email' | 'sms' | 'linkedin' | 'ai_voice'
  messageTemplate  String?  @db.Text // Template with {variables} like {firstName}, {company}
  subject          String?           // For email subject lines
  condition        String?  @db.Text // JSON condition: { "type": "phone_provided" | "linkedin_connected" | "no_response" }
  requiresApproval Boolean  @default(false)
  fallbackStepId   String?           // If condition fails, skip to this step order

  @@unique([sequenceId, stepOrder])
  @@index([sequenceId])
}

// Per-lead follow-up sequence instance (tracks progress through a sequence)
model FollowUpInstance {
  id             String   @id @default(uuid())
  leadId         String
  lead           Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  sequenceId     String
  sequence       FollowUpSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  currentStep    Int      @default(0)    // Current step order (0 = not started yet)
  status         String   @default("active")  // 'active' | 'paused' | 'completed' | 'cancelled'
  pausedReason   String?                  // Reason for pause (e.g., "lead_replied", "manual")
  startedAt      DateTime @default(now())
  lastStepAt     DateTime?                // When the last step was executed
  nextStepDue    DateTime?                // When the next step should run
  completedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([leadId, sequenceId])
  @@index([leadId])
  @@index([sequenceId])
  @@index([status])
  @@index([nextStepDue])
}

// =============================================================================
// Reactivation (CSV-based lead re-engagement)
// =============================================================================

model ReactivationCampaign {
  id                  String   @id @default(uuid())
  clientId            String
  client              Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name                String
  isActive            Boolean  @default(true)
  // Optional: lock to a single EmailBison campaign (recommended).
  emailCampaignId     String?
  emailCampaign       EmailCampaign? @relation(fields: [emailCampaignId], references: [id], onDelete: SetNull)
  // After bump send, optionally start a follow-up sequence (reuses existing sequencing system).
  followUpSequenceId  String?
  followUpSequence    FollowUpSequence? @relation(fields: [followUpSequenceId], references: [id], onDelete: SetNull)
  // Confirmed requirement: 5/day per sender email address.
  dailyLimitPerSender Int      @default(5)
  // Optional allowlist of sender_email_id values (EmailBison sender emails).
  allowedSenderEmailIds Json?
  // Default bump template. Variables: {firstName}
  bumpMessageTemplate String   @db.Text
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  enrollments         ReactivationEnrollment[]

  @@index([clientId])
  @@index([isActive])
  @@index([emailCampaignId])
  @@index([followUpSequenceId])
}

model ReactivationEnrollment {
  id                 String   @id @default(uuid())
  campaignId         String
  campaign           ReactivationCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  leadId             String
  lead               Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  status             String   @default("pending_resolution") // pending_resolution | ready | sent | rate_limited | needs_review | failed
  needsReviewReason  String?  @db.Text
  // Resolution fields (derived from EmailBison “sent” thread)
  emailBisonLeadId        String?
  anchorReplyId           String? // Reply ID to respond to for in-thread bump
  anchorCampaignId        String? // EmailBison campaign_id (most recent campaign for the sent thread)
  originalSenderEmailId   String? // sender_email_id used originally
  selectedSenderEmailId   String? // sender_email_id selected (original or fallback)
  deadOriginalSender      Boolean  @default(false)
  deadReason              String?  @db.Text
  // Scheduling + retries
  nextActionAt        DateTime?
  lastAttemptAt       DateTime?
  retryCount          Int      @default(0)
  lastError           String?  @db.Text
  resolvedAt          DateTime?
  sentAt              DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  sendLogs            ReactivationSendLog[]

  @@unique([campaignId, leadId])
  @@index([campaignId])
  @@index([leadId])
  @@index([status])
  @@index([nextActionAt])
  @@index([selectedSenderEmailId])
}

model EmailBisonSenderEmailSnapshot {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  senderEmailId String
  emailAddress  String?
  status        String?
  isSendable    Boolean  @default(true)
  raw           Json?
  fetchedAt     DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, senderEmailId])
  @@index([clientId])
  @@index([clientId, isSendable])
  @@index([fetchedAt])
}

model ReactivationSenderDailyUsage {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  senderEmailId String
  dateKey       String   // YYYY-MM-DD in workspace timezone
  count         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, senderEmailId, dateKey])
  @@index([clientId])
  @@index([senderEmailId])
  @@index([dateKey])
}

model ReactivationSendLog {
  id               String   @id @default(uuid())
  enrollmentId     String
  enrollment       ReactivationEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  stepKey          String   // e.g. "bump_1"
  channel          String   @default("email") // email | sms | linkedin (future)
  senderEmailId    String?
  anchorReplyId    String?
  providerMessageId String?
  status           String   @default("sent") // sent | skipped | error
  error            String?  @db.Text
  sentAt           DateTime @default(now())
  createdAt        DateTime @default(now())

  @@unique([enrollmentId, stepKey])
  @@index([channel])
  @@index([senderEmailId])
  @@index([sentAt(sort: Desc)])
}

// =============================================================================
// Calendar Integration
// =============================================================================

// Calendar links for availability (multiple per workspace)
model CalendarLink {
  id         String   @id @default(uuid())
  clientId   String
  client     Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name       String              // Display name (e.g., "Sales Calendar", "Demo Calls")
  url        String              // Full calendar URL (calendly.com/user/meeting)
  type       String              // 'calendly' | 'hubspot' | 'ghl' | 'unknown'
  isDefault  Boolean  @default(false)  // Default calendar for this workspace
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  // Leads that prefer this specific calendar
  leads      Lead[]
  availabilityCaches WorkspaceAvailabilityCache[]

  @@index([clientId])
  @@index([isDefault])
}

// Per-workspace cache of live availability from the default CalendarLink
// Refreshed by cron every 10 minutes (and on-demand when stale).
model WorkspaceAvailabilityCache {
  id                  String      @id @default(uuid())
  clientId            String      @unique
  client              Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  calendarLinkId      String?
  calendarLink        CalendarLink? @relation(fields: [calendarLinkId], references: [id], onDelete: SetNull)
  calendarType        String      // 'calendly' | 'hubspot' | 'ghl' | 'unknown'
  calendarUrl         String
  slotDurationMinutes Int         @default(30)
  rangeStart          DateTime
  rangeEnd            DateTime
  slotsUtc            Json        // JSON array of ISO datetimes in UTC
  providerMeta        Json?
  fetchedAt           DateTime
  staleAt             DateTime
  lastError           String?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  @@index([clientId])
  @@index([staleAt])
  @@index([calendarLinkId])
}

// Tracks how often specific availability slots have been offered to leads (soft distribution signal).
// Used to spread suggested times across the next few days before reusing the same slot.
model WorkspaceOfferedSlot {
  id            String   @id @default(uuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  slotUtc       DateTime
  offeredCount  Int      @default(0)
  lastOfferedAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([clientId, slotUtc])
  @@index([clientId])
  @@index([slotUtc])
  @@index([clientId, slotUtc])
}

// =============================================================================
// Booking Process System (Phase 36)
// =============================================================================

// Reusable booking process definition per workspace
// Defines when/how the AI offers booking links, times, and qualifying questions
model BookingProcess {
  id          String   @id @default(uuid())
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  name        String
  description String?

  // Global settings
  maxWavesBeforeEscalation Int @default(5)  // Flag for human review after N waves without booking

  stages      BookingProcessStage[]
  campaigns   EmailCampaign[]
  leadProgress LeadCampaignBookingProgress[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Supabase Auth user ID who created

  @@unique([clientId, name])
  @@index([clientId])
}

// Individual stage/wave in a booking process
// Stage numbers are global wave indices shared across channels
model BookingProcessStage {
  id                String   @id @default(uuid())
  bookingProcessId  String
  bookingProcess    BookingProcess @relation(fields: [bookingProcessId], references: [id], onDelete: Cascade)

  stageNumber       Int      // 1, 2, 3... (global wave index)

  // What to include in this stage
  includeBookingLink        Boolean @default(false)
  linkType                  BookingProcessLinkType @default(PLAIN_URL)  // SMS must use PLAIN_URL
  includeSuggestedTimes     Boolean @default(false)
  numberOfTimesToSuggest    Int     @default(3)
  includeQualifyingQuestions Boolean @default(false)
  qualificationQuestionIds  String[] @default([])  // IDs from WorkspaceSettings.qualificationQuestions
  includeTimezoneAsk        Boolean @default(false)

  // Channel applicability (which channels this stage applies to)
  applyToEmail    Boolean @default(true)
  applyToSms      Boolean @default(true)
  applyToLinkedin Boolean @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([bookingProcessId, stageNumber])
  @@index([bookingProcessId])
}

// Per-lead, per-campaign booking wave progress tracking
// Tracks which wave we're on and per-channel sent status within the wave
model LeadCampaignBookingProgress {
  id                String   @id @default(uuid())

  // Scope: per lead + per EmailCampaign
  leadId            String
  lead              Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  emailCampaignId   String
  emailCampaign     EmailCampaign @relation(fields: [emailCampaignId], references: [id], onDelete: Cascade)

  // Freeze booking process at conversation start (do not change mid-stream)
  activeBookingProcessId String?
  activeBookingProcess   BookingProcess? @relation(fields: [activeBookingProcessId], references: [id], onDelete: SetNull)

  // Global wave number (1-indexed). Stage selection uses this.
  currentWave Int @default(1)

  // "This wave already sent a message on channel X"
  waveEmailSent    Boolean @default(false)
  waveSmsSent      Boolean @default(false)
  waveLinkedinSent Boolean @default(false)

  // SMS DND hold tracking (Phase 36i: hold wave until DND clears or 72h timeout)
  smsDndHeldSince   DateTime?  // When DND hold started (null = not held)
  smsDndLastRetryAt DateTime?  // Last DND retry attempt

  // Lifetime outbound counters (used for analytics)
  emailOutboundCount    Int @default(0)
  smsOutboundCount      Int @default(0)
  linkedinOutboundCount Int @default(0)

  lastEmailOutboundAt    DateTime?
  lastSmsOutboundAt      DateTime?
  lastLinkedinOutboundAt DateTime?

  // Required question rotation tracking (Phase 36i: store which required questions were selected)
  selectedRequiredQuestionIds String[] @default([])

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([leadId, emailCampaignId])
  @@index([leadId])
  @@index([emailCampaignId])
  @@index([activeBookingProcessId])
  @@index([currentWave])
  @@index([smsDndHeldSince])  // For cron retry queries
}
